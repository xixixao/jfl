<html>
  <head>
    <title>JFL - JavaScript Standard Functional Library</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        /* Colors */
        --background-color: rgb(210, 210, 210);
        --hover-background-color: rgb(0, 112, 245);
        --hover-text-color: rgb(255, 255, 255);
        --input-background-color: rgb(255, 255, 255);
        --input-border-color: rgb(241, 241, 241);
        --input-placeholder-color: rgb(178, 178, 178);
        --secondary-text-color: rgb(0, 0, 0);
        --text-color: rgb(0, 0, 0);

        /* Sizes */
        --chevron-width: 1.5rem;
        --content-width: 44rem;
        --sidebar-content-width: 16rem;
        --min-content-width: var(--sidebar-content-width) + var(--content-width);
        --sidebar-width: var(--sidebar-content-width);

        /* Images */
        --chevron-url: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJmZWF0aGVyIGZlYXRoZXItY2hldnJvbi1yaWdodCI+PHBvbHlsaW5lIHBvaW50cz0iOSAxOCAxNSAxMiA5IDYiPjwvcG9seWxpbmU+PC9zdmc+');
      }

      @media screen and (prefers-color-scheme: dark) {
        :root {
          --background-color: rgb(30, 30, 30);
          --hover-background-color: rgb(50, 114, 246);
          --hover-text-color: rgb(255, 255, 255);
          --input-background-color: rgb(54, 54, 54);
          --input-border-color: rgb(31, 31, 31);
          --input-placeholder-color: rgb(131, 131, 131);
          --secondary-text-color: rgb(191, 191, 191);
          --text-color: rgb(255, 255, 255);
        }
      }

      /* (2 * sidebar-content-width + content-width) */
      @media screen and (min-width: 76rem) {
        :root {
          --sidebar-width: calc((100vw - var(--content-width)) / 2);
        }
      }

      body {
        -webkit-text-size-adjust: none;
        background-color: var(--background-color);
        color: var(--text-color);
        display: flex;
        font-family: 'SF Pro Text', 'Helvetica Neue', 'Helvetica', 'Arial',
          sans-serif;
        font-size: 1.063rem;
        letter-spacing: -0.022em;
        margin: 0;
        line-height: 1.5;
      }
      a {
        color: var(--text-color);
        cursor: pointer;
        text-decoration: none;
      }
      h1,
      h2,
      h3,
      h4 {
        font-family: 'SF Pro Display', 'Helvetica Neue', 'Helvetica', 'Arial',
          sans-serif;
        font-weight: 600;
        letter-spacing: 0em;
        line-height: 1.1;
        letter-spacing: 0em;
        margin-bottom: 0;
        margin-top: 0;
      }
      h1 {
        font-size: 3rem;
      }
      h2 {
        font-size: 2.5rem;
        margin-top: 3rem;
      }
      h3 {
        font-size: 2rem;
        margin-top: 2rem;
      }
      h4 {
        font-size: 1.5rem;
        padding-top: 2rem;
      }
      .sidebar {
        display: flex;
        height: 100vh;
        justify-content: flex-end;
        width: var(--sidebar-width);
      }
      .sidebarContent {
        display: flex;
        flex-direction: column;
        width: 16rem;
      }
      .sidebarSearch {
        padding: 16px;
      }
      .sidebarNavigation {
        font-family: 'SF Pro Display', 'Helvetica Neue', 'Helvetica', 'Arial',
          sans-serif;
        font-size: 0.85rem;
        overflow: auto;
        padding: 16px;
      }
      .sidebar a {
        display: block;
        padding: 4px 8px;
        border-radius: 4px;
        margin-left: var(--chevron-width);
      }
      .sidebar a:hover {
        background-color: var(--hover-background-color);
        color: var(--hover-text-color);
      }
      .sidebar .module {
        margin-left: 0;
        margin-top: 8px;
        position: relative;
        padding-left: var(--chevron-width);
      }
      .sidebar .module::before {
        -webkit-mask-image: var(--chevron-url);
        -webkit-mask-size: 1.2rem;
        background-color: var(--text-color);
        content: '';
        display: block;
        height: 1.25rem;
        left: 0.2rem;
        mask-image: var(--chevron-url);
        mask-size: 1.2rem;
        opacity: 0.5;
        opacity: 0.75;
        position: absolute;
        top: 0.3rem;
        transform: rotate(0);
        width: 1.25rem;
      }
      .sidebar .open .module::before {
        transform: rotate(90deg);
      }
      .sidebar .module:hover::before {
        background-color: var(--hover-text-color);
      }
      .sidebar .section {
        color: var(--secondary-text-color);
        font-size: 0.75rem;
        font-weight: bold;
        margin-top: 4px;
        margin-left: calc(var(--chevron-width) + 0.5rem);
        padding: 4px 8px;
        display: none;
      }
      .sidebar .function {
        margin-left: calc(var(--chevron-width) + 0.5rem);
        font-size: 0.85rem;
        display: none;
      }
      .sidebar .open .section {
        display: block;
      }
      .sidebar .open .function {
        display: block;
      }
      .main {
        flex-grow: 1;
        height: 100vh;
        overflow: auto;
      }
      .mainContent {
        padding: 28px;
      }
      .mainText {
        max-width: var(--content-width);
      }
      input[type='text'] {
        background-color: var(--input-background-color);
        border-radius: 4px;
        border: 1px solid var(--input-border-color);
        box-sizing: border-box;
        color: inherit;
        display: block;
        font-family: inherit;
        font-size: 0.75rem;
        height: 2rem;
        padding: 0.5rem;
        width: 100%;
      }
      input[type='text']:focus {
        outline: none;
        box-shadow: 0px 0px 0px 2px var(--hover-background-color);
      }
      ::placeholder {
        color: var(--input-placeholder-color);
        opacity: 1;
      }
      pre {
        background-color: var(--input-background-color);
        border-radius: 4px;
        border: 1px solid var(--input-border-color);
        font-family: Menlo, monospace;
        font-size: 1rem;
        margin-bottom: 2rem;
        padding: 1rem;
      }
    </style>
  </head>

  <body>
    <div class="sidebar">
      <div class="sidebarContent">
        <div class="sidebarSearch">
          <input type="text" placeholder="Search" />
        </div>
        <div class="sidebarNavigation">
          <a href="#intro">
            Intro
          </a>
          
      <div class="moduleExpander">
        
    <a class="module">(jfl)</a>
    <a class="function" href="#jfl">Overview</a>
  
        
        <div class="section">Type</div>
        
      <a class="function" href="#nullthrows">
        nullthrows
      </a>
    

      <a class="function" href="#invariant">
        invariant
      </a>
    
      
      </div>
    

      <div class="moduleExpander">
        
    <a class="module">Ar (array)</a>
    <a class="function" href="#ar">Overview</a>
  
        
        <div class="section">Construct</div>
        
      <a class="function" href="#Ar.from">
        Ar.from
      </a>
    

      <a class="function" href="#Ar.fromAsync">
        Ar.fromAsync
      </a>
    

      <a class="function" href="#Ar.keys">
        Ar.keys
      </a>
    

      <a class="function" href="#Ar.entries">
        Ar.entries
      </a>
    

      <a class="function" href="#Ar.range">
        Ar.range
      </a>
    

      <a class="function" href="#Ar.rangeInclusive">
        Ar.rangeInclusive
      </a>
    

      <a class="function" href="#Ar.rangeDescending">
        Ar.rangeDescending
      </a>
    

      <a class="function" href="#Ar.rangeDynamic">
        Ar.rangeDynamic
      </a>
    

      <a class="function" href="#Ar.repeat">
        Ar.repeat
      </a>
    

      <a class="function" href="#Ar.fill">
        Ar.fill
      </a>
    

      <a class="function" href="#Ar.generate">
        Ar.generate
      </a>
    

      <a class="function" href="#Ar.mutable">
        Ar.mutable
      </a>
    
      

        <div class="section">Check</div>
        
      <a class="function" href="#Ar.isArray">
        Ar.isArray
      </a>
    

      <a class="function" href="#Ar.equals">
        Ar.equals
      </a>
    

      <a class="function" href="#Ar.equalsNested">
        Ar.equalsNested
      </a>
    
      

        <div class="section">Select</div>
        
      <a class="function" href="#Ar.filter">
        Ar.filter
      </a>
    

      <a class="function" href="#Ar.filterAsync">
        Ar.filterAsync
      </a>
    

      <a class="function" href="#Ar.filterNulls">
        Ar.filterNulls
      </a>
    

      <a class="function" href="#Ar.findKeys">
        Ar.findKeys
      </a>
    

      <a class="function" href="#Ar.unique">
        Ar.unique
      </a>
    

      <a class="function" href="#Ar.uniqueBy">
        Ar.uniqueBy
      </a>
    

      <a class="function" href="#Ar.take">
        Ar.take
      </a>
    

      <a class="function" href="#Ar.drop">
        Ar.drop
      </a>
    

      <a class="function" href="#Ar.takeWhile">
        Ar.takeWhile
      </a>
    

      <a class="function" href="#Ar.dropWhile">
        Ar.dropWhile
      </a>
    

      <a class="function" href="#Ar.dropWhileFromEnd">
        Ar.dropWhileFromEnd
      </a>
    
      

        <div class="section">Divide</div>
        
      <a class="function" href="#Ar.chunk">
        Ar.chunk
      </a>
    

      <a class="function" href="#Ar.partition">
        Ar.partition
      </a>
    

      <a class="function" href="#Ar.slice">
        Ar.slice
      </a>
    

      <a class="function" href="#Ar.splice">
        Ar.splice
      </a>
    

      <a class="function" href="#Ar.splitAt">
        Ar.splitAt
      </a>
    

      <a class="function" href="#Ar.span">
        Ar.span
      </a>
    
      

        <div class="section">Combine</div>
        
      <a class="function" href="#Ar.prepend">
        Ar.prepend
      </a>
    

      <a class="function" href="#Ar.concat">
        Ar.concat
      </a>
    

      <a class="function" href="#Ar.flatten">
        Ar.flatten
      </a>
    

      <a class="function" href="#Ar.zip">
        Ar.zip
      </a>
    

      <a class="function" href="#Ar.zipWith">
        Ar.zipWith
      </a>
    

      <a class="function" href="#Ar.product">
        Ar.product
      </a>
    
      

        <div class="section">Transform</div>
        
      <a class="function" href="#Ar.map">
        Ar.map
      </a>
    

      <a class="function" href="#Ar.mapAsync">
        Ar.mapAsync
      </a>
    

      <a class="function" href="#Ar.mapMaybe">
        Ar.mapMaybe
      </a>
    

      <a class="function" href="#Ar.mapFlat">
        Ar.mapFlat
      </a>
    

      <a class="function" href="#Ar.scan">
        Ar.scan
      </a>
    
      

        <div class="section">Order</div>
        
      <a class="function" href="#Ar.reverse">
        Ar.reverse
      </a>
    

      <a class="function" href="#Ar.sort">
        Ar.sort
      </a>
    

      <a class="function" href="#Ar.sortBy">
        Ar.sortBy
      </a>
    

      <a class="function" href="#Ar.sortUnstable">
        Ar.sortUnstable
      </a>
    
      
      </div>
    

      <div class="moduleExpander">
        
    <a class="module">Cl (collection)</a>
    <a class="function" href="#cl">Overview</a>
  
        
        <div class="section">Check</div>
        
      <a class="function" href="#Cl.equals">
        Cl.equals
      </a>
    

      <a class="function" href="#Cl.equalsNested">
        Cl.equalsNested
      </a>
    

      <a class="function" href="#Cl.isEmpty">
        Cl.isEmpty
      </a>
    

      <a class="function" href="#Cl.count">
        Cl.count
      </a>
    

      <a class="function" href="#Cl.contains">
        Cl.contains
      </a>
    

      <a class="function" href="#Cl.containsKey">
        Cl.containsKey
      </a>
    

      <a class="function" href="#Cl.any">
        Cl.any
      </a>
    

      <a class="function" href="#Cl.every">
        Cl.every
      </a>
    
      

        <div class="section">Select</div>
        
      <a class="function" href="#Cl.find">
        Cl.find
      </a>
    

      <a class="function" href="#Cl.findX">
        Cl.findX
      </a>
    

      <a class="function" href="#Cl.findKey">
        Cl.findKey
      </a>
    

      <a class="function" href="#Cl.findKeyX">
        Cl.findKeyX
      </a>
    

      <a class="function" href="#Cl.first">
        Cl.first
      </a>
    

      <a class="function" href="#Cl.firstX">
        Cl.firstX
      </a>
    

      <a class="function" href="#Cl.onlyX">
        Cl.onlyX
      </a>
    

      <a class="function" href="#Cl.last">
        Cl.last
      </a>
    

      <a class="function" href="#Cl.lastX">
        Cl.lastX
      </a>
    

      <a class="function" href="#Cl.at">
        Cl.at
      </a>
    

      <a class="function" href="#Cl.atX">
        Cl.atX
      </a>
    

      <a class="function" href="#Cl.atFromEnd">
        Cl.atFromEnd
      </a>
    

      <a class="function" href="#Cl.atFromEndX">
        Cl.atFromEndX
      </a>
    

      <a class="function" href="#Cl.atDynamic">
        Cl.atDynamic
      </a>
    

      <a class="function" href="#Cl.firstKey">
        Cl.firstKey
      </a>
    

      <a class="function" href="#Cl.firstKeyX">
        Cl.firstKeyX
      </a>
    

      <a class="function" href="#Cl.lastKey">
        Cl.lastKey
      </a>
    

      <a class="function" href="#Cl.lastKeyX">
        Cl.lastKeyX
      </a>
    
      

        <div class="section">Transform</div>
        
      <a class="function" href="#Cl.forEach">
        Cl.forEach
      </a>
    

      <a class="function" href="#Cl.reduce">
        Cl.reduce
      </a>
    
      
      </div>
    

      <div class="moduleExpander">
        
    <a class="module">Mp (map)</a>
    <a class="function" href="#mp">Overview</a>
  
        
        <div class="section">Construction</div>
        
      <a class="function" href="#Mp.of">
        Mp.of
      </a>
    

      <a class="function" href="#Mp.from">
        Mp.from
      </a>
    

      <a class="function" href="#Mp.fromAsync">
        Mp.fromAsync
      </a>
    

      <a class="function" href="#Mp.fromValues">
        Mp.fromValues
      </a>
    

      <a class="function" href="#Mp.fromKeys">
        Mp.fromKeys
      </a>
    

      <a class="function" href="#Mp.fromKeysAsync">
        Mp.fromKeysAsync
      </a>
    

      <a class="function" href="#Mp.fromEntries">
        Mp.fromEntries
      </a>
    

      <a class="function" href="#Mp.unzip">
        Mp.unzip
      </a>
    

      <a class="function" href="#Mp.fromObject">
        Mp.fromObject
      </a>
    

      <a class="function" href="#Mp.toObject">
        Mp.toObject
      </a>
    

      <a class="function" href="#Mp.mutable">
        Mp.mutable
      </a>
    
      

        <div class="section">Checks</div>
        
      <a class="function" href="#Mp.isMap">
        Mp.isMap
      </a>
    

      <a class="function" href="#Mp.equals">
        Mp.equals
      </a>
    

      <a class="function" href="#Mp.equalsOrderIgnored">
        Mp.equalsOrderIgnored
      </a>
    

      <a class="function" href="#Mp.equalsNested">
        Mp.equalsNested
      </a>
    
      

        <div class="section">Combine</div>
        
      <a class="function" href="#Mp.set">
        Mp.set
      </a>
    

      <a class="function" href="#Mp.merge">
        Mp.merge
      </a>
    
      

        <div class="section">Select</div>
        
      <a class="function" href="#Mp.filter">
        Mp.filter
      </a>
    
      

        <div class="section">Transform</div>
        
      <a class="function" href="#Mp.map">
        Mp.map
      </a>
    

      <a class="function" href="#Mp.mapAsync">
        Mp.mapAsync
      </a>
    

      <a class="function" href="#Mp.mapToEntries">
        Mp.mapToEntries
      </a>
    

      <a class="function" href="#Mp.groupBy">
        Mp.groupBy
      </a>
    
      

        <div class="section">Divide</div>
        
      

        <div class="section">Ordering</div>
        
      
      </div>
    

      <div class="moduleExpander">
        
    <a class="module">Mth (math)</a>
    <a class="function" href="#mth">Overview</a>
  
        
        <div class="section">Checks</div>
        
      <a class="function" href="#Mth.isOdd">
        Mth.isOdd
      </a>
    

      <a class="function" href="#Mth.isEven">
        Mth.isEven
      </a>
    
      

        <div class="section">Operations</div>
        
      <a class="function" href="#Mth.pmod">
        Mth.pmod
      </a>
    

      <a class="function" href="#Mth.idiv">
        Mth.idiv
      </a>
    

      <a class="function" href="#Mth.divx">
        Mth.divx
      </a>
    

      <a class="function" href="#Mth.idivx">
        Mth.idivx
      </a>
    

      <a class="function" href="#Mth.squared">
        Mth.squared
      </a>
    

      <a class="function" href="#Mth.cubed">
        Mth.cubed
      </a>
    
      

        <div class="section">Collections</div>
        
      <a class="function" href="#Mth.min">
        Mth.min
      </a>
    

      <a class="function" href="#Mth.minBy">
        Mth.minBy
      </a>
    

      <a class="function" href="#Mth.maxBy">
        Mth.maxBy
      </a>
    

      <a class="function" href="#Mth.sumFloat">
        Mth.sumFloat
      </a>
    
      

        <div class="section">Bases</div>
        
      <a class="function" href="#Mth.fromBase">
        Mth.fromBase
      </a>
    
      
      </div>
    

      <div class="moduleExpander">
        
    <a class="module">REx (regexp)</a>
    <a class="function" href="#rex">Overview</a>
  
        
        <div class="section">Check</div>
        
      <a class="function" href="#REx.isRegExp">
        REx.isRegExp
      </a>
    
      

        <div class="section">Combine</div>
        
      <a class="function" href="#REx.concat">
        REx.concat
      </a>
    
      

        <div class="section">Transform</div>
        
      <a class="function" href="#REx.addFlags">
        REx.addFlags
      </a>
    

      <a class="function" href="#REx.removeFlags">
        REx.removeFlags
      </a>
    

      <a class="function" href="#REx.append">
        REx.append
      </a>
    

      <a class="function" href="#REx.prepend">
        REx.prepend
      </a>
    
      
      </div>
    

      <div class="moduleExpander">
        
    <a class="module">St (set)</a>
    <a class="function" href="#st">Overview</a>
  
        
        <div class="section">Construction</div>
        
      <a class="function" href="#St.from">
        St.from
      </a>
    

      <a class="function" href="#St.fromAsync">
        St.fromAsync
      </a>
    

      <a class="function" href="#St.mutable">
        St.mutable
      </a>
    
      

        <div class="section">Checks</div>
        
      <a class="function" href="#St.isSet">
        St.isSet
      </a>
    

      <a class="function" href="#St.equals">
        St.equals
      </a>
    

      <a class="function" href="#St.equalsOrderIgnored">
        St.equalsOrderIgnored
      </a>
    

      <a class="function" href="#St.equalsNested">
        St.equalsNested
      </a>
    
      

        <div class="section">Combine</div>
        
      <a class="function" href="#St.add">
        St.add
      </a>
    

      <a class="function" href="#St.union">
        St.union
      </a>
    

      <a class="function" href="#St.intersect">
        St.intersect
      </a>
    

      <a class="function" href="#St.diff">
        St.diff
      </a>
    

      <a class="function" href="#St.flatten">
        St.flatten
      </a>
    
      

        <div class="section">Select</div>
        
      <a class="function" href="#St.filter">
        St.filter
      </a>
    

      <a class="function" href="#St.filterAsync">
        St.filterAsync
      </a>
    

      <a class="function" href="#St.filterNulls">
        St.filterNulls
      </a>
    

      <a class="function" href="#St.findKeys">
        St.findKeys
      </a>
    
      

        <div class="section">Transform</div>
        
      <a class="function" href="#St.map">
        St.map
      </a>
    

      <a class="function" href="#St.mapAsync">
        St.mapAsync
      </a>
    

      <a class="function" href="#St.mapFlat">
        St.mapFlat
      </a>
    
      

        <div class="section">Divide</div>
        
      
      </div>
    

      <div class="moduleExpander">
        
    <a class="module">Str (string)</a>
    <a class="function" href="#str">Overview</a>
  
        
        <div class="section">Construct</div>
        
      <a class="function" href="#Str.fromNumber">
        Str.fromNumber
      </a>
    

      <a class="function" href="#Str.fromNumberInLocale">
        Str.fromNumberInLocale
      </a>
    

      <a class="function" href="#Str.repeat">
        Str.repeat
      </a>
    

      <a class="function" href="#Str.fill">
        Str.fill
      </a>
    

      <a class="function" href="#Str.toNumber">
        Str.toNumber
      </a>
    
      

        <div class="section">Checks</div>
        
      <a class="function" href="#Str.isEmpty">
        Str.isEmpty
      </a>
    

      <a class="function" href="#Str.length">
        Str.length
      </a>
    

      <a class="function" href="#Str.startsWith">
        Str.startsWith
      </a>
    

      <a class="function" href="#Str.startsWithCaseIgnored">
        Str.startsWithCaseIgnored
      </a>
    

      <a class="function" href="#Str.endsWithCaseIgnored">
        Str.endsWithCaseIgnored
      </a>
    

      <a class="function" href="#Str.includesCaseIgnored">
        Str.includesCaseIgnored
      </a>
    

      <a class="function" href="#Str.matchesCaseIgnored">
        Str.matchesCaseIgnored
      </a>
    

      <a class="function" href="#Str.indexOfCaseIgnored">
        Str.indexOfCaseIgnored
      </a>
    

      <a class="function" href="#Str.compare">
        Str.compare
      </a>
    
      

        <div class="section">Select</div>
        
      <a class="function" href="#Str.matchEvery">
        Str.matchEvery
      </a>
    

      <a class="function" href="#Str.matchFirst">
        Str.matchFirst
      </a>
    

      <a class="function" href="#Str.slice">
        Str.slice
      </a>
    

      <a class="function" href="#Str.take">
        Str.take
      </a>
    

      <a class="function" href="#Str.drop">
        Str.drop
      </a>
    

      <a class="function" href="#Str.takeWhile">
        Str.takeWhile
      </a>
    

      <a class="function" href="#Str.dropWhile">
        Str.dropWhile
      </a>
    

      <a class="function" href="#Str.trim">
        Str.trim
      </a>
    

      <a class="function" href="#Str.trimStart">
        Str.trimStart
      </a>
    

      <a class="function" href="#Str.trimEnd">
        Str.trimEnd
      </a>
    
      

        <div class="section">Combine</div>
        
      <a class="function" href="#Str.join">
        Str.join
      </a>
    

      <a class="function" href="#Str.joinChars">
        Str.joinChars
      </a>
    

      <a class="function" href="#Str.joinWords">
        Str.joinWords
      </a>
    

      <a class="function" href="#Str.joinLines">
        Str.joinLines
      </a>
    
      

        <div class="section">Divide</div>
        
      <a class="function" href="#Str.split">
        Str.split
      </a>
    

      <a class="function" href="#Str.splitAt">
        Str.splitAt
      </a>
    

      <a class="function" href="#Str.chunk">
        Str.chunk
      </a>
    

      <a class="function" href="#Str.splitChars">
        Str.splitChars
      </a>
    

      <a class="function" href="#Str.splitWords">
        Str.splitWords
      </a>
    

      <a class="function" href="#Str.splitLines">
        Str.splitLines
      </a>
    

      <a class="function" href="#Str.span">
        Str.span
      </a>
    
      

        <div class="section">Transform</div>
        
      <a class="function" href="#Str.forEachCodePoint">
        Str.forEachCodePoint
      </a>
    

      <a class="function" href="#Str.replaceEvery">
        Str.replaceEvery
      </a>
    

      <a class="function" href="#Str.replaceFirst">
        Str.replaceFirst
      </a>
    

      <a class="function" href="#Str.replaceFirstCaseIgnored">
        Str.replaceFirstCaseIgnored
      </a>
    

      <a class="function" href="#Str.capitalizeWords">
        Str.capitalizeWords
      </a>
    

      <a class="function" href="#Str.uppercase">
        Str.uppercase
      </a>
    
      
      </div>
    
        </div>
      </div>
    </div>
    <div class="main">
      <a name="intro"></a>
      <div class="mainContent">
        <div class="mainText">
          <h1>JFL - JavaScript Standard Functional Library</h1>
          <p>
            This JavaScript library aims to compliment the language to provide a
            single dependency for writing most business logic code. It is fully
            statically typed to work well with both Flow and TypeScript.
          </p>
          
      <a name="jfl"></a>
      <h2>(jfl)</h2>
      
    <p>This is the main module from which you can easily import all the others, plus a few utilities for working in Flow/TypeScript in general.</p>
    
    <pre>import {Ar, $Ar, Cl, Mp, $Mp, Mth, REx, St, $St, Str} from 'jfl'
import {nullthrows, invariant} from 'jfl'</pre>
  
      
      <h3>Type</h3>
      
      <div>
        <a name="nullthrows"></a>
        <h4>nullthrows</h4>
        
    <p>TODO</p>
    <pre>nullthrows<T>(
  value: ?T,
  message?: string = 'Got unexpected null or undefined',
): T</pre>
    
  
      </div>
    

      <div>
        <a name="invariant"></a>
        <h4>invariant</h4>
        
    <p>Work in progress.</p>
    <pre>invariant(condition: boolean, message: string): void</pre>
    
  
      </div>
    
    
    

      <a name="ar"></a>
      <h2>Ar (array)</h2>
      
    <p>This module provides functions which operate on collections (Arrays, Maps, Sets) and return read-only (immutable) arrays.</p>
    
    <pre>import {Ar} from 'jfl'</pre>
  
      
      <h3>Construct</h3>
      
      <div>
        <a name="Ar.from"></a>
        <h4>Ar.from</h4>
        
    <p>Convert any `collection` of values to an Array of values. <br /><br /> Note that this is not a way to clone an array, if passed an array, the same array will be returned.</p>
    <pre>from<V>(collection: Collection<V>): $Array<V></pre>
    <pre>Ar.from(Set(1, 2, 3)) // [1, 2, 3]
Ar.from(Mp({a: 1, b: 2, c: 3})) // [1, 2, 3]</pre>
  
      </div>
    

      <div>
        <a name="Ar.fromAsync"></a>
        <h4>Ar.fromAsync</h4>
        
    <p>Convert any `collection` of awaitable promises of values to a single promise of an Array of values.</p>
    <pre>fromAsync<V>(
  collection: Collection<Promise<V>>,
): Promise<$Array<V>></pre>
    <pre>Ar.fromAsync([(async () => 1)(), (async () => 2)()]) // [1, 2]</pre>
  
      </div>
    

      <div>
        <a name="Ar.keys"></a>
        <h4>Ar.keys</h4>
        
    <p>Convert any `collection` with keys to an Array of keys. <br /><br /> Notably the keys of a Set are just its values. The keys of an Array are its indices.</p>
    <pre>keys<K>(collection: KeyedCollection<K, any>): $Array<K></pre>
    <pre>Ar.keys([5, 6]) // [0, 1]
Ar.keys($Mp({a: 2, b: 3})) // ['a', 'b']
Ar.keys($St(3, 4) // [3, 4]</pre>
  
      </div>
    

      <div>
        <a name="Ar.entries"></a>
        <h4>Ar.entries</h4>
        
    <p>Convert any `collection` with keys to an Array of key value pairs. <br /><br /> Notably the keys of a Set are just its values. The keys of an Array are its indices.</p>
    <pre>entries<K, V>(
  collection: KeyedCollection<K, V>,
): $Array<[K, V]></pre>
    <pre>Ar.entries([5, 6]) // [[0, 5], [1, 6]]
Ar.entries($Mp({a: 2, b: 3})) // [['a', 2], ['b', 3]]
Ar.entries($St(3, 4) // [[3, 3], [4, 4]]</pre>
  
      </div>
    

      <div>
        <a name="Ar.range"></a>
        <h4>Ar.range</h4>
        
    <p>Create an array of numbers. <br /><br /> The start of the range is inclusive, the end is exclusive. By default increments by 1.</p>
    <pre>range(
  fromInclusive: number,
  toExclusive: number,
  step?: number = 1,
): $Array<number></pre>
    <pre>Ar.range(1, 6) // [1, 2, 3, 4, 5]
Ar.range(-0.5, 0.51, 0.5) // [-0.5, 0, 0.5]</pre>
  
      </div>
    

      <div>
        <a name="Ar.rangeInclusive"></a>
        <h4>Ar.rangeInclusive</h4>
        
    <p>Create an array of numbers. <br /><br /> A version of `Ar.range` where the end is inclusive.</p>
    <pre>rangeInclusive(
  fromInclusive: number,
  toInclusive: number,
  step?: number = 1,
): $Array<number></pre>
    <pre>Ar.range(-0.5, 0.5, 0.5) // [-0.5, 0, 0.5]</pre>
  
      </div>
    

      <div>
        <a name="Ar.rangeDescending"></a>
        <h4>Ar.rangeDescending</h4>
        
    <p>Create an array of numbers. <br /><br /> A version of `Ar.range` where the array of numbers has decreasing order. By default increments by -1.</p>
    <pre>rangeDescending(
  fromInclusive: number,
  toExclusive: number,
  step?: number = 1,
): $Array<number></pre>
    <pre>Ar.range(5, 1) // [5, 4, 3, 2]
Ar.range(2, 1, 0.2) // [2, 1.8, 1.6, 1.4, 1.2]</pre>
  
      </div>
    

      <div>
        <a name="Ar.rangeDynamic"></a>
        <h4>Ar.rangeDynamic</h4>
        
    <p>Create an array of numbers. <br /><br /> A version of `Ar.range` where the array of numbers has increasing or decreasing order, depending on given range limits. Both limits are inclusive.</p>
    <pre>rangeDynamic(
  fromInclusive: number,
  toInclusive: number,
  step?: number = 1,
): $Array<number></pre>
    <pre>Ar.range(2, 6, 2) // [2, 4, 6]
Ar.range(6, 2, 2) // [6, 4, 2]</pre>
  
      </div>
    

      <div>
        <a name="Ar.repeat"></a>
        <h4>Ar.repeat</h4>
        
    <p>Create an array filled with a `count` of given `value`s. <br /><br /> The `value` will be referenced, not cloned.</p>
    <pre>repeat<V>(value: V, count: number): $Array<V></pre>
    <pre>Ar.repeat(4, "a") // ["a", "a", "a", "a"]</pre>
  
      </div>
    

      <div>
        <a name="Ar.fill"></a>
        <h4>Ar.fill</h4>
        
    <p>Create an array filled with `count` results of calling `fn`. <br /><br /> `fn` take as the first argument the index where the current invocation's result will be placed.</p>
    <pre>fill<V>(count: number, fn: number => V): $Array<V></pre>
    <pre>Ar.fill(4, i => i) // [0, 1, 2, 3]</pre>
  
      </div>
    

      <div>
        <a name="Ar.generate"></a>
        <h4>Ar.generate</h4>
        
    <p>Create an array using a `seed` value and a function which given the seed returns an item to be contained in the array and a new seed value. <br /><br /> To mark the end of the array, `fn` must return `null` or `undefined`.</p>
    <pre>generate<V, S>(seed: S, fn: S => ?[V, S]): $Array<V></pre>
    <pre>Ar.generate(2, n => (n < 64 ? [n, n * n] : null)) // [2, 4, 16]</pre>
  
      </div>
    

      <div>
        <a name="Ar.mutable"></a>
        <h4>Ar.mutable</h4>
        
    <p>Convert any `collection` of values to a mutable Array of values. <br /><br /> If an array is given it will be cloned. <br /><br /> This function is useful for complicated or performance sensitive computation inside a function. Avoid passing arrays as mutable around your codebase to prevent bugs.</p>
    <pre>mutable<V>(collection: Collection<V>): Array<V></pre>
    <pre>Ar.mutable($Ar(1, 2, 3)) // [1, 2, 3]</pre>
  
      </div>
    
    

      <h3>Check</h3>
      
      <div>
        <a name="Ar.isArray"></a>
        <h4>Ar.isArray</h4>
        
    <p>Returns whether given value is an Array.</p>
    <pre>isArray(argument: mixed): %checks</pre>
    <pre>Ar.isArray([1, 2, 3]) // true</pre>
  
      </div>
    

      <div>
        <a name="Ar.equals"></a>
        <h4>Ar.equals</h4>
        
    <p>Returns whether given Arrays are equal. <br /><br /> All items must be strictly equal.</p>
    <pre>equals<V>(
  array: $Array<V>,
  ...arrays: $Array<$Array<V>>
): boolean</pre>
    <pre>Ar.equals([1, 2], [1, 2]) // true</pre>
  
      </div>
    

      <div>
        <a name="Ar.equalsNested"></a>
        <h4>Ar.equalsNested</h4>
        
    <p>Returns whether given Arrays and any nested collections are equal. <br /><br /> Any contained collections must deeply equal, all other items must be strictly equal.</p>
    <pre>equalsNested<V>(
  array: $Array<V>,
  ...arrays: $Array<$Array<V>>
): boolean</pre>
    <pre>Ar.equalsNested([[1], [2], 3], [[1], [2], 3]) // true</pre>
  
      </div>
    
    

      <h3>Select</h3>
      
      <div>
        <a name="Ar.filter"></a>
        <h4>Ar.filter</h4>
        
    <p>Create a new array by filtering out values for which `fn` returns false.</p>
    <pre>filter<V>(
  collection: Collection<V>,
  predicateFn: V => boolean,
): $Array<V></pre>
    <pre>Ar.filter([1, 2, 3], n => Mth.isOdd(n)) // [1, 3]</pre>
  
      </div>
    

      <div>
        <a name="Ar.filterAsync"></a>
        <h4>Ar.filterAsync</h4>
        
    <p>Create a promise of an array by filtering out values in `collection` for which async `fn` returns false. <br /><br /> Executes `predicateFn` on all items in `collection` concurrently.</p>
    <pre>async function filterAsync<V>(
  collection: Collection<V>,
  predicateFn: V => Promise<boolean>,
): Promise<$Array<V>></pre>
    <pre>Ar.filterAsync([1, 2, 3], async x => Mth.isOdd(x)) // [1, 3]</pre>
  
      </div>
    

      <div>
        <a name="Ar.filterNulls"></a>
        <h4>Ar.filterNulls</h4>
        
    <p>Create a new array by filtering out `null`s and `undefined`s. <br /><br /> Here because its type is more specific then the generic `filter` function.</p>
    <pre>filterNulls<V>(collection: Collection<?V>): $Array<V></pre>
    <pre>Ar.filterNulls([1, null, 3]) // [1, 3]</pre>
  
      </div>
    

      <div>
        <a name="Ar.findKeys"></a>
        <h4>Ar.findKeys</h4>
        
    <p>Create an array of keys corresponding to values passing given `predicateFn`.</p>
    <pre>findKeys<K, V>(
  collection: KeyedCollection<K, V>,
  predicateFn: V => boolean,
): $Array<K></pre>
    <pre>Ar.findKeys([1, 2, 3], n => Mth.isOdd(n)) // [1, 3]</pre>
  
      </div>
    

      <div>
        <a name="Ar.unique"></a>
        <h4>Ar.unique</h4>
        
    <p>Create an array of values from `collection` with each value included only once.</p>
    <pre>unique<V>(collection: Collection<V>): $Array<V></pre>
    <pre>Ar.unique([1, 2, 1]) // [1]</pre>
  
      </div>
    

      <div>
        <a name="Ar.uniqueBy"></a>
        <h4>Ar.uniqueBy</h4>
        
    <p>Create an array of values from `collection` with each value included only once, where value equivalence is determined by calling `identityFn` on each value. Later values overwrite previous ones.</p>
    <pre>uniqueBy<V>(
  collection: Collection<V>,
  identityFn: V => mixed,
): $Array<V></pre>
    <pre>Ar.uniqueBy([2, 4, 7], n => n % 3) // [2, 7]</pre>
  
      </div>
    

      <div>
        <a name="Ar.take"></a>
        <h4>Ar.take</h4>
        
    <p>Create an array containing the first `n` items of `collection`.</p>
    <pre>take<V>(collection: Collection<V>, n: number): $Array<V></pre>
    <pre>Ar.take([1, 2, 3], 2) // [1, 2]</pre>
  
      </div>
    

      <div>
        <a name="Ar.drop"></a>
        <h4>Ar.drop</h4>
        
    <p>Create an array containing all but the first `n` items of `collection`.</p>
    <pre>drop<V>(collection: Collection<V>, n: number): $Array<V></pre>
    <pre>Ar.drop([1, 2, 3], 2) // [3]</pre>
  
      </div>
    

      <div>
        <a name="Ar.takeWhile"></a>
        <h4>Ar.takeWhile</h4>
        
    <p>Create an array containing all the items of `collection` preceding the item for which `predicateFn` returns false.</p>
    <pre>takeWhile<V>(
  collection: Collection<V>,
  predicateFn: V => boolean,
): $Array<V></pre>
    <pre>Ar.takeWhile([1, 3, 4, 7], Mth.isOdd) // [1]</pre>
  
      </div>
    

      <div>
        <a name="Ar.dropWhile"></a>
        <h4>Ar.dropWhile</h4>
        
    <p>Create an array containing all the items of `collection` following and including the first item for which `predicateFn` returns false.</p>
    <pre>dropWhile<V>(
  collection: Collection<V>,
  predicateFn: V => boolean,
): $Array<V></pre>
    <pre>Ar.dropWhile([1, 3, 4, 7], Mth.isOdd) // [3, 4, 7]</pre>
  
      </div>
    

      <div>
        <a name="Ar.dropWhileFromEnd"></a>
        <h4>Ar.dropWhileFromEnd</h4>
        
    <p>Create an array containing all the items of `collection` preceding and including the first item when iterating from the end for which `predicateFn` returns false.</p>
    <pre>dropWhileFromEnd<V>(
  collection: Collection<V>,
  predicateFn: V => boolean,
): $Array<V></pre>
    <pre>Ar.dropWhileFromEnd([1, 3, 4, 7], Mth.isOdd) // [1, 3, 4]</pre>
  
      </div>
    
    

      <h3>Divide</h3>
      
      <div>
        <a name="Ar.chunk"></a>
        <h4>Ar.chunk</h4>
        
    <p>Create an array of arrays which are chunks of given `collection` of `size`. <br /><br /> If the `collection` doesn't divide evenly, the final chunk will be smaller than the rest.</p>
    <pre>chunk<V>(
  collection: Collection<V>,
  size: number,
): $Array<$Array<V>></pre>
    <pre>Ar.chunk([1, 2, 3, 4, 5], 2)</pre>
  
      </div>
    

      <div>
        <a name="Ar.partition"></a>
        <h4>Ar.partition</h4>
        
    <p>Create a tuple of Arrays containing items of `collection` which match and don't match `predicateFn` respectively. <br /><br /> More effecient combination of `Ar.filter` and `Ar.filter` combined with `Fn.not`.</p>
    <pre>partition<V>(
  collection: Collection<V>,
  predicateFn: V => boolean,
): [$Array<V>, $Array<V>]</pre>
    <pre>Ar.partition([1, 2, 3, 4], Mth.isEven)</pre>
  
      </div>
    

      <div>
        <a name="Ar.slice"></a>
        <h4>Ar.slice</h4>
        
    <p>Create an array containing a subset of values in `collection`. <br /><br /> Note that this is not a way to clone an array, if given an array and indices corresponding to its full size it returns the original array. <br /><br /> Either index can be negative, in which case they are counted from the end of the `collection`, with last element being at index `-1`.</p>
    <pre>slice<V>(
  collection: Collection<V>,
  startIndexInclusive: number,
  endIndexExclusive?: number,
): $Array<V></pre>
    <pre>Ar.slice([1, 2, 3, 4, 5], 1, 2) // [2, 3]
Ar.slice([1, 2, 3, 4, 5], -2, -1) // [3, 4]</pre>
  
      </div>
    

      <div>
        <a name="Ar.splice"></a>
        <h4>Ar.splice</h4>
        
    <p>Create an array containing a subset of values in `collection` with any given `item`s added. <br /><br /> Note that unlikely Array.prototype.splice this function returns the new array, not the deleted items.</p>
    <pre>splice<V>(
  collection: Collection<V>,
  startIndex: number,
  deleteCount?: number,
  ...items: $Array<V>
): $Array<V></pre>
    <pre>Ar.slice([1, 2, 3, 4], 1, 3)</pre>
  
      </div>
    

      <div>
        <a name="Ar.splitAt"></a>
        <h4>Ar.splitAt</h4>
        
    <p>Create a tuple of arrays containing the first `n` items and all but the first `n` items of given `collection`.</p>
    <pre>splitAt<V>(
  collection: Collection<V>,
  n: number,
): [$Array<V>, $Array<V>]</pre>
    <pre>Ar.split([1, 2, 3], 2) // [[1, 2], [3]]</pre>
  
      </div>
    

      <div>
        <a name="Ar.span"></a>
        <h4>Ar.span</h4>
        
    <p>Create a tuple of arrays containing all the items of `collection` following and preceding the first item for which `fn` returns false.</p>
    <pre>span<V>(
  collection: Collection<V>,
  fn: V => boolean,
): [$Array<V>, $Array<V>]</pre>
    <pre>Ar.span([1, 3, 4, 7], Mth.isOdd)</pre>
  
      </div>
    
    

      <h3>Combine</h3>
      
      <div>
        <a name="Ar.prepend"></a>
        <h4>Ar.prepend</h4>
        
    <p>Work in progress.</p>
    <pre>prepend<V>(collection: Collection<V>, item: V): Collection<V></pre>
    
  
      </div>
    

      <div>
        <a name="Ar.concat"></a>
        <h4>Ar.concat</h4>
        
    <p>Concatenate multiple arrays together.</p>
    <pre>concat<V>(...collections: $Array<Collection<V>>): $Array<V></pre>
    <pre>Ar.concat([1, 2], [3, 4]) // [1, 2, 3, 4]</pre>
  
      </div>
    

      <div>
        <a name="Ar.flatten"></a>
        <h4>Ar.flatten</h4>
        
    <p>Concatenate a collection of arrays together.</p>
    <pre>flatten<V>(
  collectionOfArrays: Collection<Collection<V>>,
): $Array<V></pre>
    <pre>Ar.flatten([[1, 2], [3, 4]]) // [1, 2, 3, 4]</pre>
  
      </div>
    

      <div>
        <a name="Ar.zip"></a>
        <h4>Ar.zip</h4>
        
    <p>Join `collections` into an array of tuples of values from each collection. <br /><br /> The resulting array has the same length as the smallest given collection. Excess values are ignored.</p>
    <pre>zip<V, Cs: $Array<Collection<mixed>>>(
  ...collections: Cs
): $Array<TupleOfValues<Cs>></pre>
    <pre>Ar.zip([1, 2], ['a', 'b'], [5, 6]) // [[1, 'a', 5], [2, 'b', 6]]</pre>
  
      </div>
    

      <div>
        <a name="Ar.zipWith"></a>
        <h4>Ar.zipWith</h4>
        
    <p>Join multiple `collections` into an array of values resulting form calling `fn` on items from each collection. <br /><br /> Note that this function has unusual order of arguments because JavaScript enforces that the rest parameter is the last one. The resulting array has the same length as the smallest given collection. Excess values are ignored.</p>
    <pre>zipWith<I, Cs: $Array<Collection<I>>, O>(
  fn: (...collections: TupleOfValues<Cs>) => O,
  ...collections: Cs
): $Array<O></pre>
    <pre>Ar.zipWith((a, b, c) => a + b * c, [1, 2, 3], [5, 6, 7], [2, 4, 6])</pre>
  
      </div>
    

      <div>
        <a name="Ar.product"></a>
        <h4>Ar.product</h4>
        
    <p>Join `collections` into an array of tuples of values of all combinations from each collection. <br /><br /> The resulting array has the length which is the product of the lengths of each collection.</p>
    <pre>product<V, Cs: $Array<Collection<mixed>>>(
  ...collections: Cs
): $Array<TupleOfValues<Cs>></pre>
    <pre>Ar.product([1, 2], ['a', 'b']) // [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]</pre>
  
      </div>
    
    

      <h3>Transform</h3>
      
      <div>
        <a name="Ar.map"></a>
        <h4>Ar.map</h4>
        
    <p>TODO: consider using KeyedCollection and always passing key to `fn` Create a new array by calling given `fn` on each value of `collection`.</p>
    <pre>map<VFrom, VTo>(
  collection: Collection<VFrom>,
  fn: VFrom => VTo,
): $Array<VTo></pre>
    <pre>Ar.map([1, 2], x => x * 2) // [2, 4]</pre>
  
      </div>
    

      <div>
        <a name="Ar.mapAsync"></a>
        <h4>Ar.mapAsync</h4>
        
    <p>Create a promise of an array by calling given async `fn` on each value of `collection`. <br /><br /> Executes `fn` on all items in `collection` concurrently.</p>
    <pre>mapAsync<VFrom, VTo>(
  collection: Collection<VFrom>,
  fn: VFrom => Promise<VTo>,
): Promise<$Array<VTo>></pre>
    <pre>await Ar.mapAsync([1, 2], async x => x * 2) // [2, 4]</pre>
  
      </div>
    

      <div>
        <a name="Ar.mapMaybe"></a>
        <h4>Ar.mapMaybe</h4>
        
    <p>Create a new array by calling given `fn` on each value of `collection` and and including the result if it is not null or undefined. <br /><br /> Equivalent to using `map` followed by `filterNulls`, for simplicity and improved performance.</p>
    <pre>mapMaybe<VFrom, VTo>(
  collection: Collection<VFrom>,
  fn: VFrom => ?VTo,
): $Array<VTo></pre>
    <pre>Ar.mapMaybe([1, 2, 3], x => Math.isOdd(x) ? x * x : null) // [1, 9]</pre>
  
      </div>
    

      <div>
        <a name="Ar.mapFlat"></a>
        <h4>Ar.mapFlat</h4>
        
    <p>Create a new array by calling given `fn` on each value of `collection` and flattening the results. <br /><br /> Equivalent to using `map` followed by `flatten`, for simplicity and improved performance.</p>
    <pre>mapFlat<VFrom, VTo>(
  collection: Collection<VFrom>,
  fn: VFrom => Collection<VTo>,
): $Array<VTo></pre>
    <pre>Ar.mapFlat([1, 2], x => [x - 1, x + 1]) // [0, 2, 1, 3]</pre>
  
      </div>
    

      <div>
        <a name="Ar.scan"></a>
        <h4>Ar.scan</h4>
        
    <p>Create an array of values based on a reduction of given `collection`. <br /><br /> Similar to `Cl.reduce` but instead of returning the final value accumulates all the intermediate accumulators.</p>
    <pre>scan<I, O>(
  collection: Collection<I>,
  initialValue: O,
  fn: (O, I) => O,
): $Array<O></pre>
    <pre>Ar.scan([1, 2, 3, 4], 0, (acc, x) => acc + x) // [1, 3, 6, 10]</pre>
  
      </div>
    
    

      <h3>Order</h3>
      
      <div>
        <a name="Ar.reverse"></a>
        <h4>Ar.reverse</h4>
        
    <p>Create an array containing the items of `collection` in reverse order.</p>
    <pre>reverse<V>(collection: Collection<V>): $Array<V></pre>
    <pre>Ar.reverse([1, 2, 3])</pre>
  
      </div>
    

      <div>
        <a name="Ar.sort"></a>
        <h4>Ar.sort</h4>
        
    <p>Create an array of values in `collection` sorted. <br /><br /> The result of calling `compareFn` on values `a` and `b` determines their order: negative number: `a`, `b` positive number: `b`, `a` zero: the order stays the same as it was in `collection` The default `compareFn` is `(a, b) => a > b ? 1 : a < b ? -1 : 0`, which sorts numbers and strings in ascending order (from small to large, from early in the alphabet to later in the alphabet). <br /><br /> This sort preserves the order of elements when `compareFn` returns 0 at the cost of using more memory.</p>
    <pre>sort<V>(
  collection: Collection<V>,
  compareFn?: (a: V, b: V) => number = defaultCompareFn,
): $Array<V></pre>
    <pre>Ar.sort([3, 2, 4, 1]) // [1, 2, 3, 4]</pre>
  
      </div>
    

      <div>
        <a name="Ar.sortBy"></a>
        <h4>Ar.sortBy</h4>
        
    <p>Create an array of values in `collection` sorted by the scalar computed by calling `scalarFn` on each value. <br /><br /> The result of calling `compareFn` on scalars `a` and `b` determines the order of the corresponding values: negative number: `a`, `b` positive number: `b`, `a` zero: the order stays the same as it was in `collection` The default `compareFn` is `(a, b) => a > b ? 1 : a < b ? -1 : 0`, which sorts numbers and strings in ascending order (from small to large, from early in the alphabet to later in the alphabet). <br /><br /> This sort preserves the order of elements when `compareFn` returns 0 at the cost of using more memory.</p>
    <pre>sortBy<V, S>(
  collection: Collection<V>,
  scalarFn: V => S,
  compareFn?: (a: S, b: S) => number = defaultCompareFn,
): $Array<V></pre>
    <pre>Ar.sortBy([3, 2, 4, 1], n => n % 3) // [3, 4, 1, 2]</pre>
  
      </div>
    

      <div>
        <a name="Ar.sortUnstable"></a>
        <h4>Ar.sortUnstable</h4>
        
    <p>Create an array of values in `collection` sorted. <br /><br /> The result of calling `compareFn` on values `a` and `b` determines their order: negative number: `a`, `b` positive number: `b`, `a` zero: the order is undetermined The default `compareFn` is `(a, b) => a > b ? 1 : a < b ? -1 : 0`, which sorts numbers and strings in ascending order (from small to large, from early in the alphabet to later in the alphabet). <br /><br /> This sort doesn't preserve the order of elements when `compareFn` returns 0 which makes it more memory efficient.</p>
    <pre>sortUnstable<V>(
  collection: Collection<V>,
  compareFn?: (V, V) => number = defaultCompareFn,
): $Array<V></pre>
    <pre>Ar.sortUnstable([3, 2, 4, 1]) // 1, 2, 3, 4</pre>
  
      </div>
    
    
    

      <a name="cl"></a>
      <h2>Cl (collection)</h2>
      
    <p>Work in progress.</p>
    
    
  
      
      <h3>Check</h3>
      
      <div>
        <a name="Cl.equals"></a>
        <h4>Cl.equals</h4>
        
    <p>Returns whether given collections are equal. <br /><br /> All items must be strictly equal.</p>
    <pre>equals<V, C: Collection<V>>(
  first: C,
  ...rest: $Array<C>
): boolean</pre>
    <pre>Cl.equals([1, 2], [1, 2]) // true</pre>
  
      </div>
    

      <div>
        <a name="Cl.equalsNested"></a>
        <h4>Cl.equalsNested</h4>
        
    <p>Returns whether given collections and any nested collections are equal. <br /><br /> Any contained collections must deeply equal, all other items must be strictly equal.</p>
    <pre>equalsNested<V, C: mixed>(
  first: C,
  ...rest: $Array<C>
): boolean</pre>
    <pre>Cl.equalsNested([[1], [2], 3], [[1], [2], 3]) // true</pre>
  
      </div>
    

      <div>
        <a name="Cl.isEmpty"></a>
        <h4>Cl.isEmpty</h4>
        
    <p>Returns true when `collection` is empty.</p>
    <pre>isEmpty<V>(collection: Collection<V>): boolean</pre>
    <pre>Cl.isEmpty(Ar()) // true
Cl.isEmpty(Mp()) // true
Cl.isEmpty(St()) // true</pre>
  
      </div>
    

      <div>
        <a name="Cl.count"></a>
        <h4>Cl.count</h4>
        
    <p>Get the size of given `collection`.</p>
    <pre>count<V>(collection: Collection<V>): number</pre>
    <pre>Cl.count([1, 2, 3]) // 3
Cl.count(Mp({a: 1, b: 3})) // 2</pre>
  
      </div>
    

      <div>
        <a name="Cl.contains"></a>
        <h4>Cl.contains</h4>
        
    <p>Returns whether given `collection` contains given `value`.</p>
    <pre>contains<V>(collection: Collection<V>, value: V): boolean</pre>
    <pre>Cl.contains([2, 4, 3], 1) // true
Cl.contains(St(2, 4, 3), 4) // true
Cl.contains(Mp({a: 1, b: 3}), 1) // true</pre>
  
      </div>
    

      <div>
        <a name="Cl.containsKey"></a>
        <h4>Cl.containsKey</h4>
        
    <p>Returns whether given `key` exists in keyed `collection`.</p>
    <pre>containsKey<K, V>(
  collection: KeyedCollection<K, V>,
  key: K,
): boolean</pre>
    <pre>Cl.contains([2, 4, 3], 1)
Cl.contains(St(2, 4, 3), 4)
Cl.contains(Mp({a: 1, b: 3}), 'a')</pre>
  
      </div>
    

      <div>
        <a name="Cl.any"></a>
        <h4>Cl.any</h4>
        
    <p>Returns whether some values satisfy `predicateFn`.</p>
    <pre>any<K, V>(
  collection: KeyedCollection<K, V>,
  predicateFn: (V, K, KeyedCollection<K, V>) => boolean,
): boolean</pre>
    <pre>Cl.any([1, 5, 4], n => Mth.isEven(n)) // true</pre>
  
      </div>
    

      <div>
        <a name="Cl.every"></a>
        <h4>Cl.every</h4>
        
    <p>Returns whether all values satisfy `predicateFn`.</p>
    <pre>every<K, V>(
  collection: KeyedCollection<K, V>,
  predicateFn: (V, K, KeyedCollection<K, V>) => boolean,
): boolean</pre>
    <pre>Cl.every([1, 5, 3], n => Mth.isOdd(n)) // true</pre>
  
      </div>
    
    

      <h3>Select</h3>
      
      <div>
        <a name="Cl.find"></a>
        <h4>Cl.find</h4>
        
    <p>Returns the first value for which `predicateFn` returns true in `collection`, if any.</p>
    <pre>find<V>(
  collection: Collection<V>,
  predicateFn: V => boolean,
): ?V</pre>
    <pre>Cl.find([2, 4], n => Mth.isOdd(n)) // null
Cl.find([2, 4, 3], n => Mth.isOdd(n)) // 2</pre>
  
      </div>
    

      <div>
        <a name="Cl.findX"></a>
        <h4>Cl.findX</h4>
        
    <p>Returns first value for which `predicateFn` returns true in `collection`.</p>
    <pre>findX<V>(
  collection: Collection<V>,
  predicateFn: V => boolean,
): V</pre>
    <pre>Cl.find([2, 4, 3], n => Mth.isOdd(n)) // 2</pre>
  
      </div>
    

      <div>
        <a name="Cl.findKey"></a>
        <h4>Cl.findKey</h4>
        
    <p>Returns the key of the first value for which `predicateFn` returns true in `collection`, if any.</p>
    <pre>findKey<K, V>(
  collection: KeyedCollection<K, V>,
  predicateFn: (V, K) => boolean,
): ?K</pre>
    <pre>Cl.findKey([2, 4, 3], n => Mth.isOdd(n)) // 2</pre>
  
      </div>
    

      <div>
        <a name="Cl.findKeyX"></a>
        <h4>Cl.findKeyX</h4>
        
    <p>Returns the key of the first value for which `predicateFn` returns true in `collection`.</p>
    <pre>findKeyX<K, V>(
  collection: KeyedCollection<K, V>,
  predicateFn: (V, K) => boolean,
): K</pre>
    <pre>Cl.findKey([2, 4, 3], n => Mth.isOdd(n)) // 2</pre>
  
      </div>
    

      <div>
        <a name="Cl.first"></a>
        <h4>Cl.first</h4>
        
    <p>Returns the first value in `collection` if it's not empty, null otherwise.</p>
    <pre>first<V>(collection: Collection<V>): ?V</pre>
    <pre>Cl.first(Ar()) // null
Cl.first([1, 3]) // 1</pre>
  
      </div>
    

      <div>
        <a name="Cl.firstX"></a>
        <h4>Cl.firstX</h4>
        
    <p>Returns the first value in `collection` if it's not empty, throws otherwise.</p>
    <pre>firstX<V>(collection: Collection<V>): V</pre>
    <pre>Cl.firstX([1, 3]) // 1</pre>
  
      </div>
    

      <div>
        <a name="Cl.onlyX"></a>
        <h4>Cl.onlyX</h4>
        
    <p>Returns the one and only value in `collection`, throws otherwise.</p>
    <pre>onlyX<V>(collection: Collection<V>): V</pre>
    <pre>Cl.firstX([1]) // 1</pre>
  
      </div>
    

      <div>
        <a name="Cl.last"></a>
        <h4>Cl.last</h4>
        
    <p>Returns the last value in `collection` if it's not empty, null otherwise.</p>
    <pre>last<V>(collection: Collection<V>): ?V</pre>
    <pre>Cl.last(Ar()) // null
Cl.last([1, 3]) // 3</pre>
  
      </div>
    

      <div>
        <a name="Cl.lastX"></a>
        <h4>Cl.lastX</h4>
        
    <p>Returns the last value in `collection` if it's not empty, throws otherwise.</p>
    <pre>lastX<V>(collection: Collection<V>): V</pre>
    <pre>Cl.lastX([1, 3]) // 3</pre>
  
      </div>
    

      <div>
        <a name="Cl.at"></a>
        <h4>Cl.at</h4>
        
    <p>Returns the value at given iteration `index` or null. <br /><br /> For accessing values using corresponding keys use `Map.prototype.get` or `Set.prototype.has`, which are all correctly typed.</p>
    <pre>at<V>(collection: Collection<V>, index: number): ?V</pre>
    <pre>Cl.at(St(), 2) // null
Cl.at(St('a', 'b', 'c'), 2) // 'c'</pre>
  
      </div>
    

      <div>
        <a name="Cl.atX"></a>
        <h4>Cl.atX</h4>
        
    <p>Returns the value at given iteration index or throws.</p>
    <pre>atX<V>(collection: Collection<V>, index: number): V</pre>
    <pre>Cl.atX(St('a', 'b', 'c'), 2) // 'c'</pre>
  
      </div>
    

      <div>
        <a name="Cl.atFromEnd"></a>
        <h4>Cl.atFromEnd</h4>
        
    <p>Returns the value at `index` as if iterating through the `collection` in reverse order or null.</p>
    <pre>atFromEnd<V>(collection: Collection<V>, index: number): ?V</pre>
    <pre>Cl.atFromEnd([], 2) // null
Cl.atFromEnd([1, 2, 3, 4], 0) // 4
Cl.atFromEnd([1, 2, 3, 4], 3) // 1</pre>
  
      </div>
    

      <div>
        <a name="Cl.atFromEndX"></a>
        <h4>Cl.atFromEndX</h4>
        
    <p>Returns the value at `index` as if iterating through the `collection` in reverse order or throws.</p>
    <pre>atFromEndX<V>(collection: Collection<V>, index: number): V</pre>
    <pre>Cl.atFromEndX([1, 2, 3, 4], 0) // 4
Cl.atFromEndX([1, 2, 3, 4], 3) // 1</pre>
  
      </div>
    

      <div>
        <a name="Cl.atDynamic"></a>
        <h4>Cl.atDynamic</h4>
        
    <p>Return element at `index` counting from start if it's positive and counting from end if it's negative, with last element being at index `-1`.</p>
    <pre>atDynamic<V>(collection: Collection<V>, index: number): ?V</pre>
    <pre>Cl.atDynamic([1, 2, 3, 4], 0) // 1
Cl.atDynamic([1, 2, 3, 4], -2) // 3</pre>
  
      </div>
    

      <div>
        <a name="Cl.firstKey"></a>
        <h4>Cl.firstKey</h4>
        
    <p>Returns the first key in `collection` if it's not empty, null otherwise.</p>
    <pre>firstKey<K, V>(collection: KeyedCollection<K, V>): ?K</pre>
    <pre>Cl.firstKey(Mp()) // null
Cl.firstKey(Mp({a: 1, b: 2})) // 'a'</pre>
  
      </div>
    

      <div>
        <a name="Cl.firstKeyX"></a>
        <h4>Cl.firstKeyX</h4>
        
    <p>Returns the first key in `collection` if it's not empty, throws otherwise.</p>
    <pre>firstKeyX<K, V>(collection: KeyedCollection<K, V>): K</pre>
    <pre>Cl.firstKeyX(Mp({a: 1, b: 2})) // 1</pre>
  
      </div>
    

      <div>
        <a name="Cl.lastKey"></a>
        <h4>Cl.lastKey</h4>
        
    <p>Returns the last key in `collection` if it's not empty, null otherwise.</p>
    <pre>lastKey<K, V>(collection: KeyedCollection<K, V>): ?K</pre>
    <pre>Cl.lastKey(Mp()) // null
Cl.lastKey(Mp({a: 1, b: 2})) // 'b'</pre>
  
      </div>
    

      <div>
        <a name="Cl.lastKeyX"></a>
        <h4>Cl.lastKeyX</h4>
        
    <p>Returns the last key in `collection` if it's not empty, throws otherwise.</p>
    <pre>lastKeyX<K, V>(collection: KeyedCollection<K, V>): K</pre>
    <pre>Cl.lastKeyX(Mp({a: 1, b: 2})) // 'b'</pre>
  
      </div>
    
    

      <h3>Transform</h3>
      
      <div>
        <a name="Cl.forEach"></a>
        <h4>Cl.forEach</h4>
        
    <p>Execute `fn` for every value and key in `collection`.</p>
    <pre>forEach<K, V>(
  collection: KeyedCollection<K, V>,
  fn: (V, K, KeyedCollection<K, V>) => void,
): void</pre>
    <pre>Cl.forEach([1, 2, 3], (n, index, array) => {})</pre>
  
      </div>
    

      <div>
        <a name="Cl.reduce"></a>
        <h4>Cl.reduce</h4>
        
    <p>Reduce the collection to a single value using `fn`. <br /><br /> If no `initialValue` is passed in, the collection must be non-empty.</p>
    <pre>reduce(collection, fn, initialValue)</pre>
    <pre>Cl.reduce([2, 4, 3], (acc, x) => acc + x) // 9</pre>
  
      </div>
    
    
    

      <a name="mp"></a>
      <h2>Mp (map)</h2>
      
    <p>Work in progress.</p>
    
    
  
      
      <h3>Construction</h3>
      
      <div>
        <a name="Mp.of"></a>
        <h4>Mp.of</h4>
        
    <p>Create a map from given `pairs` of keys and values.</p>
    <pre>of<K, V>(...pairs: $Array<[K, V]>): $Map<K, V></pre>
    <pre>Mp.of([0, 2], [4, 2])</pre>
  
      </div>
    

      <div>
        <a name="Mp.from"></a>
        <h4>Mp.from</h4>
        
    <p>Convert any keyed `collection` to a Map. <br /><br /> Note that this is not a way to clone a map, if passed a map, the same map will be returned.</p>
    <pre>from<K, V>(collection: KeyedCollection<K, V>): $Map<K, V></pre>
    <pre>Mp.from([1, 2, 3])
Mp.from(Set(1, 2, 3))</pre>
  
      </div>
    

      <div>
        <a name="Mp.fromAsync"></a>
        <h4>Mp.fromAsync</h4>
        
    <p>Convert any keyed `collection` of promises to a Map.</p>
    <pre>async function fromAsync<K, V>(
  collection: KeyedCollection<K, Promise<V>>,
): Promise<$Map<K, V>></pre>
    <pre>Mp.fromAsync([(async () => 1)(), (async () => 2)()])</pre>
  
      </div>
    

      <div>
        <a name="Mp.fromValues"></a>
        <h4>Mp.fromValues</h4>
        
    <p>TODO:</p>
    <pre>fromValues<K, V>(
  collection: Collection<V>,
  getKey: V => K,
): $Map<K, V></pre>
    <pre>Mp.fromValues()</pre>
  
      </div>
    

      <div>
        <a name="Mp.fromKeys"></a>
        <h4>Mp.fromKeys</h4>
        
    <p>TODO:</p>
    <pre>fromKeys<K, V>(
  collection: Collection<K>,
  getValue: K => V,
): $Map<K, V></pre>
    
  
      </div>
    

      <div>
        <a name="Mp.fromKeysAsync"></a>
        <h4>Mp.fromKeysAsync</h4>
        
    <p>TODO:</p>
    <pre>async function fromKeysAsync<K, V>(
  collection: Collection<K>,
  getValue: K => Promise<V>,
): Promise<$Map<K, V>></pre>
    
  
      </div>
    

      <div>
        <a name="Mp.fromEntries"></a>
        <h4>Mp.fromEntries</h4>
        
    <p></p>
    <pre>fromEntries<K, V>(collection: Collection<[K, V]>): $Map<K, V></pre>
    
  
      </div>
    

      <div>
        <a name="Mp.unzip"></a>
        <h4>Mp.unzip</h4>
        
    <p>Create a Map from given `keys` and `values`. <br /><br /> If there are more `keys` than `values` or vice versa, ignores the excess items.</p>
    <pre>unzip<K, V>(
  keys: Collection<K>,
  values: Collection<V>,
): $Map<K, V></pre>
    
  
      </div>
    

      <div>
        <a name="Mp.fromObject"></a>
        <h4>Mp.fromObject</h4>
        
    <p>Create a JavaScript Object from a string-keyed Map.</p>
    <pre>fromObject<K: string, V>(
  object: $ReadOnly<{[key: K]: V}>,
): KeyedCollection<K, V></pre>
    <pre>Mp.toObject(Mp({a: 1, b: 2}))</pre>
  
      </div>
    

      <div>
        <a name="Mp.toObject"></a>
        <h4>Mp.toObject</h4>
        
    <p>Create a JavaScript Object from a string-keyed Map.</p>
    <pre>toObject<K: string, V>(
  collection: KeyedCollection<K, V>,
): {[key: K]: V}</pre>
    <pre>Mp.toObject(Mp({a: 1, b: 2}))</pre>
  
      </div>
    

      <div>
        <a name="Mp.mutable"></a>
        <h4>Mp.mutable</h4>
        
    <p>Convert any keyed `collection` to a mutable Map. <br /><br /> If a map is given, it will be cloned.</p>
    <pre>mutable<K, V>(collection: KeyedCollection<K, V>): $Map<K, V></pre>
    <pre>Mp.from([1, 2, 3])
Mp.from(Set(1, 2, 3))</pre>
  
      </div>
    
    

      <h3>Checks</h3>
      
      <div>
        <a name="Mp.isMap"></a>
        <h4>Mp.isMap</h4>
        
    <p>Returns whether given value is a Map. <br /><br /> Use `instanceof Map` directly if you need the type system to pick up the refinement.</p>
    <pre>isMap(argument: mixed): %checks</pre>
    <pre>Mp.isMap([1, 2, 3])</pre>
  
      </div>
    

      <div>
        <a name="Mp.equals"></a>
        <h4>Mp.equals</h4>
        
    <p>Returns whether given Maps are equal. <br /><br /> All values and keys must be strictly equal.</p>
    <pre>equals<K, V>(
  map: $Map<K, V>,
  ...maps: $Array<$Map<K, V>>
): boolean</pre>
    <pre>Mp.equals(Mp({a: 1, b: 2}), Mp({a: 1, b: 2}))</pre>
  
      </div>
    

      <div>
        <a name="Mp.equalsOrderIgnored"></a>
        <h4>Mp.equalsOrderIgnored</h4>
        
    <p>Returns whether given Maps contain the same key/value pairs. <br /><br /> All values and keys must be strictly equal.</p>
    <pre>equalsOrderIgnored<K, V>(
  map: $Map<K, V>,
  ...maps: $Array<$Map<K, V>>
): boolean</pre>
    <pre>Mp.equalsOrderIgnored(Mp({a: 1, b: 2}), Mp({b: 2, a: 1}))</pre>
  
      </div>
    

      <div>
        <a name="Mp.equalsNested"></a>
        <h4>Mp.equalsNested</h4>
        
    <p>Returns whether given Maps are equal. <br /><br /> Any collection values or keys must deeply equal, all other values and keys must be strictly equal.</p>
    <pre>equalsNested<K, V>(
  map: $Map<K, V>,
  ...maps: $Array<$Map<K, V>>
): boolean</pre>
    <pre>Mp.equalsNested(Mp.of([[0], [1]]]), Mp.of([[0], [1]]]))</pre>
  
      </div>
    
    

      <h3>Combine</h3>
      
      <div>
        <a name="Mp.set"></a>
        <h4>Mp.set</h4>
        
    <p>Create a new Map by adding or replacing `value` under `key` in given keyed `collection`.</p>
    <pre>set<K, V>(
  collection: KeyedCollection<K, V>,
  key: K,
  value: V,
): $Map<K, V></pre>
    <pre>Mp.set(Mp({a: 1}), 'b', 2)</pre>
  
      </div>
    

      <div>
        <a name="Mp.merge"></a>
        <h4>Mp.merge</h4>
        
    <p>Create a new Map by merging all given `collections`. Later values will override earlier values.</p>
    <pre>merge<K, V>(
  ...collections: $Array<KeyedCollection<K, V>>
): $Map<K, V></pre>
    <pre>Mp.merge(Mp({a: 1, b: 2}), Mp({a: 2, c: 3}))</pre>
  
      </div>
    
    

      <h3>Select</h3>
      
      <div>
        <a name="Mp.filter"></a>
        <h4>Mp.filter</h4>
        
    <p>TODO</p>
    <pre>filter<K, V>(
  collection: KeyedCollection<K, V>,
  predicate: V => boolean,
): $Map<K, V></pre>
    
  
      </div>
    
    

      <h3>Transform</h3>
      
      <div>
        <a name="Mp.map"></a>
        <h4>Mp.map</h4>
        
    <p>Create a new map by calling given `fn` on each value and key of `collection`.</p>
    <pre>map<KFrom, VFrom, VTo>(
  collection: KeyedCollection<KFrom, VFrom>,
  fn: (VFrom, KFrom) => VTo,
): $Map<KFrom, VTo></pre>
    <pre>Mp.map([1, 2], (x, i) => x * 2)</pre>
  
      </div>
    

      <div>
        <a name="Mp.mapAsync"></a>
        <h4>Mp.mapAsync</h4>
        
    <p>Create a promise of a map by calling given async `fn` on each value and key of `collection`. <br /><br /> Executes `fn` on all items in `collection` concurrently.</p>
    <pre>async function mapAsync<KFrom, VFrom, VTo>(
  collection: KeyedCollection<KFrom, VFrom>,
  fn: (VFrom, KFrom) => Promise<VTo>,
): Promise<$Map<KFrom, VTo>></pre>
    <pre>await Ar.mapAsync([1, 2], async x => x * 2)</pre>
  
      </div>
    

      <div>
        <a name="Mp.mapToEntries"></a>
        <h4>Mp.mapToEntries</h4>
        
    <p>Create a new map by calling given `fn` on each key and value of `collection`. <br /><br /> `fn` must return new entries to populate the map.</p>
    <pre>mapToEntries<KFrom, VFrom, KTo, VTo>(
  collection: KeyedCollection<KFrom, VFrom>,
  fn: (VFrom, KFrom) => [KTo, VTo],
): $Map<KTo, VTo></pre>
    <pre>Mp.mapToEntries(['a', 'b'], (x, i) => [x, i])</pre>
  
      </div>
    

      <div>
        <a name="Mp.groupBy"></a>
        <h4>Mp.groupBy</h4>
        
    <p>Create a new map by grouping values from `collection` for which `fn` returns the same key. <br /><br /> The new map has Arrays of original values as its values. Values for which `fn` returns null or undefined are ommited.</p>
    <pre>groupBy<V, KTo>(
  collection: Collection<V>,
  fn: V => ?KTo,
): $Map<KTo, $Array<V>></pre>
    <pre>Mp.group([1, 2, 3], n => Mth.isOdd(n))</pre>
  
      </div>
    
    

      <h3>Divide</h3>
      
    

      <h3>Ordering</h3>
      
    
    

      <a name="mth"></a>
      <h2>Mth (math)</h2>
      
    <p>Work in progress.</p>
    
    
  
      
      <h3>Checks</h3>
      
      <div>
        <a name="Mth.isOdd"></a>
        <h4>Mth.isOdd</h4>
        
    <p>Returns true when `n` is an odd integer.</p>
    <pre>isOdd(n: number): boolean</pre>
    <pre>Mth.isOdd(-3)</pre>
  
      </div>
    

      <div>
        <a name="Mth.isEven"></a>
        <h4>Mth.isEven</h4>
        
    <p>Returns true when `n` is an even integer.</p>
    <pre>isEven(n: number): boolean</pre>
    <pre>Mth.isEven(-10)</pre>
  
      </div>
    
    

      <h3>Operations</h3>
      
      <div>
        <a name="Mth.pmod"></a>
        <h4>Mth.pmod</h4>
        
    <p>Returns the remainder of dividing `numerator` by `divisor`, unlike the `%` operator the result will always be positive.</p>
    <pre>pmod(numerator: number, divisor: number): number</pre>
    <pre>Mth.pmod(-13, 5) // 2</pre>
  
      </div>
    

      <div>
        <a name="Mth.idiv"></a>
        <h4>Mth.idiv</h4>
        
    <p>Returns the integer division of `numerator` by `divisor`.</p>
    <pre>idiv(numerator: number, divisor: number): number</pre>
    <pre>Mth.idiv(10, 3) // 3</pre>
  
      </div>
    

      <div>
        <a name="Mth.divx"></a>
        <h4>Mth.divx</h4>
        
    <p>Returns the result of dividing `numerator` by `divisor`. Throws an error if `divisor` is 0.</p>
    <pre>divx(numerator: number, divisor: number): number</pre>
    <pre>Mth.divx(5, 0) // throws an error</pre>
  
      </div>
    

      <div>
        <a name="Mth.idivx"></a>
        <h4>Mth.idivx</h4>
        
    <p>Returns the integer division of `numerator` by `divisor`. Throws an error if `divisor` is 0.</p>
    <pre>idivx(numerator: number, divisor: number): number</pre>
    <pre>Mth.idivx(10, 0) // throws an error</pre>
  
      </div>
    

      <div>
        <a name="Mth.squared"></a>
        <h4>Mth.squared</h4>
        
    <p>Returns the `n` squared.</p>
    <pre>squared(n: number): number</pre>
    <pre>Mth.squared(3) // 9</pre>
  
      </div>
    

      <div>
        <a name="Mth.cubed"></a>
        <h4>Mth.cubed</h4>
        
    <p>Returns the `n` cubed.</p>
    <pre>cubed(n: number): number</pre>
    <pre>Mth.cubed(3) // 27</pre>
  
      </div>
    
    

      <h3>Collections</h3>
      
      <div>
        <a name="Mth.min"></a>
        <h4>Mth.min</h4>
        
    <p>Returns the smallest of all values in `collection`, null if it's empty.</p>
    <pre>min(collection: Collection<number>): ?number</pre>
    <pre>Mth.min($Mp({a: 5, b: 2, c: 8})) // 2
Mth.min([]) // null</pre>
  
      </div>
    

      <div>
        <a name="Mth.minBy"></a>
        <h4>Mth.minBy</h4>
        
    <p>TODO:</p>
    <pre>minBy() {}

/**
 * TODO:
 */
export function max(collection: Collection<number>): ?number</pre>
    
  
      </div>
    

      <div>
        <a name="Mth.maxBy"></a>
        <h4>Mth.maxBy</h4>
        
    <p>TODO:</p>
    <pre>maxBy() {}

/**
 * TODO:
 */
export function mean() {}

/**
 * TODO:
 */
export function median() {}

/**
 * Returns the sum of all values in `collection`.
 *
 * @ex Mth.sum([1, 2, 3]) // 6
 * @see Mth.product
 */
export function sum<K>(collection: KeyedCollection<K, number>): number</pre>
    
  
      </div>
    

      <div>
        <a name="Mth.sumFloat"></a>
        <h4>Mth.sumFloat</h4>
        
    <p>TODO:</p>
    <pre>sumFloat() {}

/**
 * Returns the product of all values in `collection`.
 *
 * @ex Mth.product([2, 3, 4]) // 24
 * @see Mth.sum
 */
export function product<K>(collection: KeyedCollection<K, number>): number</pre>
    
  
      </div>
    
    

      <h3>Bases</h3>
      
      <div>
        <a name="Mth.fromBase"></a>
        <h4>Mth.fromBase</h4>
        
    <p>TODO:</p>
    <pre>fromBase() {}

/**
 * TODO:
 */
export function baseConvert() {}

/**
 * TODO:
 */
export function toBase() {}
</pre>
    
  
      </div>
    
    
    

      <a name="rex"></a>
      <h2>REx (regexp)</h2>
      
    <p>Work in progress.</p>
    
    
  
      
      <h3>Check</h3>
      
      <div>
        <a name="REx.isRegExp"></a>
        <h4>REx.isRegExp</h4>
        
    <p>TODO</p>
    <pre>isRegExp(value: mixed): %checks</pre>
    
  
      </div>
    
    

      <h3>Combine</h3>
      
      <div>
        <a name="REx.concat"></a>
        <h4>REx.concat</h4>
        
    <p>Work in progress.</p>
    <pre>concat(...patterns: $Array<RegExp>): RegExp</pre>
    
  
      </div>
    
    

      <h3>Transform</h3>
      
      <div>
        <a name="REx.addFlags"></a>
        <h4>REx.addFlags</h4>
        
    <p>TODO</p>
    <pre>addFlags(pattern: RegExp, flags: string): RegExp</pre>
    
  
      </div>
    

      <div>
        <a name="REx.removeFlags"></a>
        <h4>REx.removeFlags</h4>
        
    <p>TODO</p>
    <pre>removeFlags(pattern: RegExp, flags: string): RegExp</pre>
    
  
      </div>
    

      <div>
        <a name="REx.append"></a>
        <h4>REx.append</h4>
        
    <p>TODO</p>
    <pre>append(pattern: RegExp, appended: string | RegExp): RegExp</pre>
    
  
      </div>
    

      <div>
        <a name="REx.prepend"></a>
        <h4>REx.prepend</h4>
        
    <p>TODO</p>
    <pre>prepend(pattern: RegExp, prepended: string | RegExp): RegExp</pre>
    
  
      </div>
    
    
    

      <a name="st"></a>
      <h2>St (set)</h2>
      
    <p>Work in progress.</p>
    
    
  
      
      <h3>Construction</h3>
      
      <div>
        <a name="St.from"></a>
        <h4>St.from</h4>
        
    <p>Convert any `collection` of values to a Set of values. <br /><br /> Note that this is not a way to clone a set, if passed a set, the same set will be returned.</p>
    <pre>from<V>(collection: Collection<V>): $Set<V></pre>
    <pre>St.from([1, 2, 3])
St.from(Mp({a: 1, b: 2, c: 3}))</pre>
  
      </div>
    

      <div>
        <a name="St.fromAsync"></a>
        <h4>St.fromAsync</h4>
        
    <p>Convert any `collection` of awaitable promises of values to a single promise of a Set of values.</p>
    <pre>async function fromAsync<V>(
  collection: Collection<Promise<V>>,
): Promise<$Set<V>></pre>
    <pre>St.fromAsync([(async () => 1)(), (async () => 2)()])</pre>
  
      </div>
    

      <div>
        <a name="St.mutable"></a>
        <h4>St.mutable</h4>
        
    <p>Convert any `collection` of values to a mutable Set of values. <br /><br /> If a set is given it will be cloned.</p>
    <pre>mutable<V>(collection: Collection<V>): Set<V></pre>
    <pre>St.mutable($St(1, 2, 3)) // Set {1, 2, 3}</pre>
  
      </div>
    
    

      <h3>Checks</h3>
      
      <div>
        <a name="St.isSet"></a>
        <h4>St.isSet</h4>
        
    <p>Returns whether given argument is a Set.</p>
    <pre>isSet(argument: mixed): %checks</pre>
    <pre>St.isSet(St(1, 2, 3))</pre>
  
      </div>
    

      <div>
        <a name="St.equals"></a>
        <h4>St.equals</h4>
        
    <p>Returns whether given Sets are equal. <br /><br /> All items must be strictly equal.</p>
    <pre>equals<V>(set: $Set<V>, ...sets: $Array<$Set<V>>): boolean</pre>
    <pre>St.equals([1, 2], [1, 2])</pre>
  
      </div>
    

      <div>
        <a name="St.equalsOrderIgnored"></a>
        <h4>St.equalsOrderIgnored</h4>
        
    <p>Returns whether given Sets contain the same values. <br /><br /> All items must be strictly equal.</p>
    <pre>equalsOrderIgnored<V>(
  set: $Set<V>,
  ...sets: $Array<$Set<V>>
): boolean</pre>
    <pre>St.unorderdEquals([1, 2], [1, 2])</pre>
  
      </div>
    

      <div>
        <a name="St.equalsNested"></a>
        <h4>St.equalsNested</h4>
        
    <p>Returns whether given Sets and any nested collections are equal. <br /><br /> Any contained collections must deeply equal, all other items must be strictly equal.</p>
    <pre>equalsNested<V>(
  set: $Set<V>,
  ...sets: $Array<$Set<V>>
): boolean</pre>
    <pre>Ar.equalsNested([[1], [2], 3], [[1], [2], 3])</pre>
  
      </div>
    
    

      <h3>Combine</h3>
      
      <div>
        <a name="St.add"></a>
        <h4>St.add</h4>
        
    <p>Create a Set which is a union of all values in given `collections`.</p>
    <pre>add<V>(collection: Collection<V>, value: V): $Set<V></pre>
    <pre>St.union(St(1, 2, 3), St(1, 4, 5))</pre>
  
      </div>
    

      <div>
        <a name="St.union"></a>
        <h4>St.union</h4>
        
    <p>Create a Set which is a union of all values in given `collections`.</p>
    <pre>union<V>(...collections: $Array<Collection<V>>): $Set<V></pre>
    <pre>St.union(St(1, 2, 3), St(1, 4, 5))</pre>
  
      </div>
    

      <div>
        <a name="St.intersect"></a>
        <h4>St.intersect</h4>
        
    <p>Create a Set which is an intersection of all values in given `collections`.</p>
    <pre>intersect<V>(...collections: $Array<Collection<V>>): $Set<V></pre>
    <pre>St.intersect(St(1, 2, 3), St(2, 3, 6), St(0, 1, 2))</pre>
  
      </div>
    

      <div>
        <a name="St.diff"></a>
        <h4>St.diff</h4>
        
    <p>Create a Set which has the values from `collection` that do not appear in any of the given `collections`.</p>
    <pre>diff<V>(
  collection: Collection<V>,
  ...collections: $Array<Collection<V>>
): $Set<V></pre>
    <pre>St.diff(St(1, 2, 3), St(2, 4), St(1, 2, 4))</pre>
  
      </div>
    

      <div>
        <a name="St.flatten"></a>
        <h4>St.flatten</h4>
        
    <p>Create a Set which is a union of all values in given `collections`.</p>
    <pre>flatten<V>(collections: $Array<Collection<V>>): $Set<V></pre>
    <pre>St.flatten([St(1, 2, 3), St(1, 4, 5)])</pre>
  
      </div>
    
    

      <h3>Select</h3>
      
      <div>
        <a name="St.filter"></a>
        <h4>St.filter</h4>
        
    <p>Create a new set by filtering out values for which `fn` returns false.</p>
    <pre>filter<V>(
  collection: Collection<V>,
  fn: V => boolean,
): $Set<V></pre>
    <pre>St.filter(St(1, 2, 3), Mth.isOdd)</pre>
  
      </div>
    

      <div>
        <a name="St.filterAsync"></a>
        <h4>St.filterAsync</h4>
        
    <p>Create a promise of an array by filtering out values in `collection` for which async `fn` returns false. <br /><br /> Executes `predicate` on all items in `collection` concurrently.</p>
    <pre>async function filterAsync<V>(
  collection: Collection<V>,
  predicate: V => Promise<boolean>,
): Promise<$Set<V>></pre>
    <pre>Ar.filterAsync([1, 2, 3], async x => Mth.isOdd(x))</pre>
  
      </div>
    

      <div>
        <a name="St.filterNulls"></a>
        <h4>St.filterNulls</h4>
        
    <p>Create a new set by filtering out `null`s and `undefined`s. <br /><br /> Here because its type is more specific then the generic `filter` function.</p>
    <pre>filterNulls<V>(collection: Collection<?V>): $Set<V></pre>
    <pre>St.filterNulls([1, null, 3])</pre>
  
      </div>
    

      <div>
        <a name="St.findKeys"></a>
        <h4>St.findKeys</h4>
        
    <p>Create a set of keys corresponding to values passing given `predicateFn`.</p>
    <pre>findKeys<K, V>(
  collection: KeyedCollection<K, V>,
  predicateFn: V => boolean,
): $Set<K></pre>
    <pre>St.findKeys([1, 2, 3], n => Mth.isOdd(n)) // $St(1, 3)</pre>
  
      </div>
    
    

      <h3>Transform</h3>
      
      <div>
        <a name="St.map"></a>
        <h4>St.map</h4>
        
    <p>Create a new set by calling given `fn` on each value of `collection`.</p>
    <pre>map<VFrom, VTo>(
  collection: Collection<VFrom>,
  fn: VFrom => VTo,
): $Set<VTo></pre>
    <pre>St.map([1, 2], x => x * 2)</pre>
  
      </div>
    

      <div>
        <a name="St.mapAsync"></a>
        <h4>St.mapAsync</h4>
        
    <p>Create a promise of a set by calling given async `fn` on each value of `collection`. <br /><br /> Executes `fn` on all items in `collection` concurrently.</p>
    <pre>async function mapAsync<VFrom, VTo>(
  collection: Collection<VFrom>,
  fn: VFrom => Promise<VTo>,
): Promise<$Set<VTo>></pre>
    <pre>await St.mapAsync([1, 2], async x => x * 2)</pre>
  
      </div>
    

      <div>
        <a name="St.mapFlat"></a>
        <h4>St.mapFlat</h4>
        
    <p>Create a new set by calling given `fn` on each value of `collection` and flattening the results. <br /><br /> Equivalent to using `map` followed by `flatten`, for simplicity and improved performance.</p>
    <pre>mapFlat<VFrom, VTo>(
  collection: Collection<VFrom>,
  fn: VFrom => Collection<VTo>,
): $Set<VTo></pre>
    <pre>Ar.mapFlat([1, 2], x => [x - 1, x + 1]) // [0, 2, 1, 3]</pre>
  
      </div>
    
    

      <h3>Divide</h3>
      
    
    

      <a name="str"></a>
      <h2>Str (string)</h2>
      
    <p>Work in progress.</p>
    
    
  
      
      <h3>Construct</h3>
      
      <div>
        <a name="Str.fromNumber"></a>
        <h4>Str.fromNumber</h4>
        
    <p>Create the string representation of `number`, with given number of `decimals`, which defaults to 0, and optionally using a different `decimalPoint` and adding a `thousandsSeparator`. <br /><br /> For a string represention that shows all present decimals use `String(number)`.</p>
    <pre>fromNumber(
  number: number,
  decimals?: number = 0,
  decimalPoint?: string = '.',
  thousandsSeparator?: string = '',
): string</pre>
    <pre>Str.fromNumber(1234.56) // '1234'
Str.fromNumber(1234.56, 1) // '1234.6'
Str.fromNumber(1234.56, 4) // '1234.5600'
Str.fromNumber(1234.56, 2, ',', '.') // '1.234,56'</pre>
  
      </div>
    

      <div>
        <a name="Str.fromNumberInLocale"></a>
        <h4>Str.fromNumberInLocale</h4>
        
    <p>Create the string representation of `number` based on the execution environment. <br /><br /> See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat for full details. <br /><br /> There is currently no counter part, ie no `Str.toNumberFromLocale`, because there is no such API in JavaScript.</p>
    <pre>fromNumberInLocale(
  number: number,
  locales?: string | Array<string>,
  options?: Intl$NumberFormatOptions,
)</pre>
    
  
      </div>
    

      <div>
        <a name="Str.repeat"></a>
        <h4>Str.repeat</h4>
        
    <p>Create a new string by repeating `string` `count` times.</p>
    <pre>repeat(string: string, count: number): string</pre>
    <pre>Str.repeat('abr', 3) // 'abrabrabr'</pre>
  
      </div>
    

      <div>
        <a name="Str.fill"></a>
        <h4>Str.fill</h4>
        
    <p>Create a new string by concatenating `count` results of calling `fn`. <br /><br /> `fn` take as the first argument the position in the final string where the current invocation's result will be placed.</p>
    <pre>fill(times: number, fn: number => string): string</pre>
    <pre>Str.fill(4, i => `${i}`) // '1234'</pre>
  
      </div>
    

      <div>
        <a name="Str.toNumber"></a>
        <h4>Str.toNumber</h4>
        
    <p>Return the number represented by given `string`.</p>
    <pre>toNumber(
  string: string,
  decimalPoint?: string = '.',
  thousandsSeparator?: string = '',
)</pre>
    <pre>Str.toNumber('1234.56') // 1234.56
Str.fromNumber('1.234,56', ',', '.') // 1234.56</pre>
  
      </div>
    
    

      <h3>Checks</h3>
      
      <div>
        <a name="Str.isEmpty"></a>
        <h4>Str.isEmpty</h4>
        
    <p>Returns true when `string` has zero length.</p>
    <pre>isEmpty(string: string): boolean</pre>
    <pre>Str.isEmpty('') // true
Str.isEmpty('a') // false</pre>
  
      </div>
    

      <div>
        <a name="Str.length"></a>
        <h4>Str.length</h4>
        
    <p>Returns the length of the `string`.</p>
    <pre>length(string: string)</pre>
    <pre>Str.length('') // 0
Str.length('aa') // 2</pre>
  
      </div>
    

      <div>
        <a name="Str.startsWith"></a>
        <h4>Str.startsWith</h4>
        
    <p>Work in progress.</p>
    <pre>startsWith(string: string, prefix: string | RegExp)</pre>
    
  
      </div>
    

      <div>
        <a name="Str.startsWithCaseIgnored"></a>
        <h4>Str.startsWithCaseIgnored</h4>
        
    <p>Work in progress.</p>
    <pre>startsWithCaseIgnored() {}

// TODO: 3545
export function endsWith(string: string, suffix: string | RegExp)</pre>
    
  
      </div>
    

      <div>
        <a name="Str.endsWithCaseIgnored"></a>
        <h4>Str.endsWithCaseIgnored</h4>
        
    <p>Work in progress.</p>
    <pre>endsWithCaseIgnored() {}

/**
 * Returns whether `string` includes `search`.
 *
 * If `fromIndex` is given then the occurence must be at or after it.
 *
 * @time O(n)
 * @space Worst case O(2^m) (O(n) when `search` is a regex and
 *        `fromIndex` is used)
 * @ex Str.includes("abcd", "c") // true
 * @ex Str.includes("ab cd", /\s/) // true
 * @alias contains, search, find
 * @see Str.indexOf, Str.matchFirst
 */
export function includes(
  string: string,
  search: string | RegExp,
  fromIndex?: number,
): boolean</pre>
    
  
      </div>
    

      <div>
        <a name="Str.includesCaseIgnored"></a>
        <h4>Str.includesCaseIgnored</h4>
        
    <p>Work in progress.</p>
    <pre>includesCaseIgnored() {}

/**
 * Returns whether `string` matches the regular expression `search`.
 *
 * To compare two strings, use `a === b`.
 *
 * @time O(n)
 * @space Worst case O(2^m)
 * @ex Str.matches("abcd", /abcd/) // true
 * @ex Str.includes("abcde", /abcd/) // false
 * @alias test, equals
 * @see Str.includes, Str.matchFirst
 */
export function matches(string: string, search: RegExp): boolean</pre>
    
  
      </div>
    

      <div>
        <a name="Str.matchesCaseIgnored"></a>
        <h4>Str.matchesCaseIgnored</h4>
        
    <p>Work in progress.</p>
    <pre>matchesCaseIgnored() {}

/**
 * Returns the index of the first occurence of `search` in `string` or null.
 *
 * If `fromIndex` is given then the occurence must be at or after it.
 *
 * @time O(n)
 * @space Worst case O(2^m) (O(n) when `search` is a regex and
 *        `fromIndex` is used)
 * @ex Str.indexOf("abcd", "c") // 2
 * @ex Str.indexOf("ab cd", "/\s/") // 2
 * @alias search, firstIndexOf, find
 * @see Str.includes, Str.matchFirst
 */
export function indexOf(
  string: string,
  search: string | RegExp,
  fromIndex?: number,
): ?number</pre>
    
  
      </div>
    

      <div>
        <a name="Str.indexOfCaseIgnored"></a>
        <h4>Str.indexOfCaseIgnored</h4>
        
    <p>Work in progress.</p>
    <pre>indexOfCaseIgnored() {}

// TODO: 570 this is lastIndexOf
export function lastIndexOf() {}

// TODO:
export function lastIndexOfCaseIgnored() {}

/**
 * Returns the number of times `search` occurs in `string`.
 *
 * @time O(n)
 * @space Worst case O(2^m)
 * @ex Str.countMatches("abcd", "c") // 1
 * @ex Str.countMatches("ab cd", /\s/) // 1
 * @see Str.includes, Str.matchEvery
 */
export function countMatches(string: string, search: string | RegExp): number</pre>
    
  
      </div>
    

      <div>
        <a name="Str.compare"></a>
        <h4>Str.compare</h4>
        
    <p>Work in progress.</p>
    <pre>compare() {}
// TODO: 1658 not sure this is needed
export function compareCaseIgnored() {}
</pre>
    
  
      </div>
    
    

      <h3>Select</h3>
      
      <div>
        <a name="Str.matchEvery"></a>
        <h4>Str.matchEvery</h4>
        
    <p>Returns every match corresponding to `search` that occurs in `string`. <br /><br /> See `Str.matchFirst` for the description of the values in the returned array.</p>
    <pre>matchEvery(
  string: string,
  search: string | RegExp,
): $Array<RegExp$matchResult></pre>
    <pre>Str.matchEvery("a b1cd", /\w+/) // [['a'], ['b'], ['cd']]</pre>
  
      </div>
    

      <div>
        <a name="Str.matchFirst"></a>
        <h4>Str.matchFirst</h4>
        
    <p>Returns the first match corresponding to `search` that occurs in `string` or null. <br /><br /> If a matching substring is present the result will be an array where the first element is the full matching substring followed by smaller substrings corresponding to any matching regex groups. The array will have the property `index` which is the index at which the match occured in `string` and the property `groups` which will contain an object mapping named regex groups to the matching substrings, or undefined if there were no named groups in `search`. <br /><br /> If `search` is a regex with the `g` flag the flag will be ignored.</p>
    <pre>matchFirst(
  string: string,
  search: string | RegExp,
): ?RegExp$matchResult</pre>
    <pre>Str.matchFirst("apple", /\w+(pp)?/) // ['app', 'pp'] {index: 0}</pre>
  
      </div>
    

      <div>
        <a name="Str.slice"></a>
        <h4>Str.slice</h4>
        
    <p>Work in progress.</p>
    <pre>slice(
  string: string,
  startIndex: number,
  endIndex?: number,
): string</pre>
    
  
      </div>
    

      <div>
        <a name="Str.take"></a>
        <h4>Str.take</h4>
        
    <p>Work in progress.</p>
    <pre>take(string: string, n: number): string</pre>
    
  
      </div>
    

      <div>
        <a name="Str.drop"></a>
        <h4>Str.drop</h4>
        
    <p>Work in progress.</p>
    <pre>drop(string: string, n: number): string</pre>
    
  
      </div>
    

      <div>
        <a name="Str.takeWhile"></a>
        <h4>Str.takeWhile</h4>
        
    <p>Work in progress.</p>
    <pre>takeWhile(
  string: string,
  predicateFn: string => boolean,
): string</pre>
    
  
      </div>
    

      <div>
        <a name="Str.dropWhile"></a>
        <h4>Str.dropWhile</h4>
        
    <p>Work in progress.</p>
    <pre>dropWhile(
  string: string,
  predicateFn: string => boolean,
): string</pre>
    
  
      </div>
    

      <div>
        <a name="Str.trim"></a>
        <h4>Str.trim</h4>
        
    <p>Returns `string` with whitespace stripped from the beginning and end. <br /><br /> If `search` is given it will stripped instead from both ends. The beginning will be trimmed first.</p>
    <pre>trim(string: string, search?: string | RegExp): string</pre>
    
  
      </div>
    

      <div>
        <a name="Str.trimStart"></a>
        <h4>Str.trimStart</h4>
        
    <p>Returns `string` with whitespace stripped from its beginning. <br /><br /> If `prefix` is given it will stripped instead.</p>
    <pre>trimStart(string: string, prefix?: string | RegExp): string</pre>
    
  
      </div>
    

      <div>
        <a name="Str.trimEnd"></a>
        <h4>Str.trimEnd</h4>
        
    <p>Returns `string` with whitespace stripped from its end. <br /><br /> If `suffix` is given it will stripped instead.</p>
    <pre>trimEnd(string: string, suffix?: string | RegExp): string</pre>
    
  
      </div>
    
    

      <h3>Combine</h3>
      
      <div>
        <a name="Str.join"></a>
        <h4>Str.join</h4>
        
    <p>TODO:</p>
    <pre>join(collection: Collection<string>, glue: string): string</pre>
    
  
      </div>
    

      <div>
        <a name="Str.joinChars"></a>
        <h4>Str.joinChars</h4>
        
    <p>Work in progress.</p>
    <pre>joinChars(chars: Collection<string>)</pre>
    
  
      </div>
    

      <div>
        <a name="Str.joinWords"></a>
        <h4>Str.joinWords</h4>
        
    <p>Work in progress.</p>
    <pre>joinWords(words: Collection<string>)</pre>
    
  
      </div>
    

      <div>
        <a name="Str.joinLines"></a>
        <h4>Str.joinLines</h4>
        
    <p>Work in progress.</p>
    <pre>joinLines(lines: Collection<string>)</pre>
    
  
      </div>
    
    

      <h3>Divide</h3>
      
      <div>
        <a name="Str.split"></a>
        <h4>Str.split</h4>
        
    <p>Work in progress.</p>
    <pre>split(
  string: string,
  delimiter: string | RegExp,
  limit?: number,
): $Array<string></pre>
    
  
      </div>
    

      <div>
        <a name="Str.splitAt"></a>
        <h4>Str.splitAt</h4>
        
    <p>Create a tuple of strings containing the first `n` characters and all but the first `n` characters of given `string`.</p>
    <pre>splitAt(string: string, n: number): [string, string]</pre>
    <pre>Str.split("hello", 2) // ["he", "llo"]</pre>
  
      </div>
    

      <div>
        <a name="Str.chunk"></a>
        <h4>Str.chunk</h4>
        
    <p>Work in progress.</p>
    <pre>chunk() {}

// TODO: 276
export function chunkFromEnd(string: string, size: number)</pre>
    
  
      </div>
    

      <div>
        <a name="Str.splitChars"></a>
        <h4>Str.splitChars</h4>
        
    <p>TODO:</p>
    <pre>splitChars(string: string): $Array<string></pre>
    
  
      </div>
    

      <div>
        <a name="Str.splitWords"></a>
        <h4>Str.splitWords</h4>
        
    <p>Work in progress.</p>
    <pre>splitWords(string: string): $Array<string></pre>
    
  
      </div>
    

      <div>
        <a name="Str.splitLines"></a>
        <h4>Str.splitLines</h4>
        
    <p>Work in progress.</p>
    <pre>splitLines(
  string: string,
  ignoreTrailingNewLine?: boolean = false,
): $Array<string></pre>
    
  
      </div>
    

      <div>
        <a name="Str.span"></a>
        <h4>Str.span</h4>
        
    <p>Work in progress.</p>
    <pre>span() {}
// TODO: 210
export function splice() {}
</pre>
    
  
      </div>
    
    

      <h3>Transform</h3>
      
      <div>
        <a name="Str.forEachCodePoint"></a>
        <h4>Str.forEachCodePoint</h4>
        
    <p>Work in progress.</p>
    <pre>forEachCodePoint(
  string: string,
  fn: (string, number) => boolean,
): void</pre>
    
  
      </div>
    

      <div>
        <a name="Str.replaceEvery"></a>
        <h4>Str.replaceEvery</h4>
        
    <p>TODO</p>
    <pre>replaceEvery(
  string: string,
  search: string | RegExp,
  replacement:
    | string
    | ((match: string, ...groupsAndOffset: Array<any>) => string),
)</pre>
    
  
      </div>
    

      <div>
        <a name="Str.replaceFirst"></a>
        <h4>Str.replaceFirst</h4>
        
    <p>TODO</p>
    <pre>replaceFirst(
  string: string,
  search: string | RegExp,
  replacement:
    | string
    | ((match: string, ...groupsAndOffset: Array<any>) => string),
)</pre>
    
  
      </div>
    

      <div>
        <a name="Str.replaceFirstCaseIgnored"></a>
        <h4>Str.replaceFirstCaseIgnored</h4>
        
    <p>Work in progress.</p>
    <pre>replaceFirstCaseIgnored() {}
// TODO: 1337
export function replaceEveryCaseIgnored() {}
// TODO:
export function camelize() {}

// TODO: 1351
export function capitalize(string: string): string</pre>
    
  
      </div>
    

      <div>
        <a name="Str.capitalizeWords"></a>
        <h4>Str.capitalizeWords</h4>
        
    <p>Work in progress.</p>
    <pre>capitalizeWords() {}
// TODO:
export function dasherize() {}
// TODO:
export function underscorize() {}
// TODO: 15578
export function lowercase(string: string): string</pre>
    
  
      </div>
    

      <div>
        <a name="Str.uppercase"></a>
        <h4>Str.uppercase</h4>
        
    <p>Work in progress.</p>
    <pre>uppercase() {}
// TODO: 420
export function padStart() {}
// TODO: 317
export function padEnd() {}
</pre>
    
  
      </div>
    
    
    
        </div>
      </div>
    </div>
    <script>
      (function (_) {
  'use strict';

  // 

  /// Transform

  /**
   * Execute `fn` for every value and key in `collection`.
   *
   * @time O(n)
   * @space O(1)
   * @ex Cl.forEach([1, 2, 3], (n, index, array) => {})
   * @alias each
   */
  function forEach(
    collection,
    fn,
  ) {
    return collection.forEach(fn);
  }

  // TODO
  // isSorted
  // isSortedBy

  // 

  const collapsible = document.querySelectorAll('.sidebar a.module');
  forEach(collapsible, link => {
    link.addEventListener(
      'click',
      (e) => {
        const parent = ((((e.target)).parentNode));
        parent.classList.toggle('open');
      },
      true,
    );
  });

}())

    </script>
  </body>
</html>
